![coverpage](../images/numpy-cover.jpeg)

#### 0.NumPy – அறிமுகம் மற்றும் வரலாறு

ஒரு சாதாரண காரில் பயணிப்பதற்கும், ஒரு ஃபார்முலா 1 பந்தயக் காரில் சீறிப் பாய்வதற்கும் உள்ள வித்தியாசத்தை உங்களால் உணர முடிகிறதா? Python நிரலாக்க மொழியில், அதன் வழக்கமான `list`-களைப் பயன்படுத்துவது சாதாரண காரில் பயணம் செய்வது போல. ஆனால், **NumPy** என்ற நூலகத்தைப் பயன்படுத்துவது, ஒரு பந்தயக் காரின் வேகத்தை உங்களுக்குக் கொடுப்பது போல!

**NumPy** (Numerical Python என்பதன் சுருக்கம்) என்பது Python மொழியில் அறிவியல் மற்றும் கணிதக் கணக்கீடுகளைச் செய்வதற்கான ஒரு திறந்த மூல (open-source) நூலகம். இது வெறும் ஒரு நூலகம் மட்டுமல்ல, Python-ஐ தரவு அறிவியல் (Data Science), இயந்திர கற்றல் (Machine Learning) போன்ற துறைகளின் முடிசூடா மன்னனாக மாற்றிய ஒரு புரட்சிகரமான கருவி. இதன் மையப் புள்ளி, அதன் சக்திவாய்ந்த **பன்முக அணி (multi-dimensional array)** அமைப்புதான்.

##### 0.க. ஒரு புதிய கருவியின் தேவை

கதை 1990-களில் தொடங்குகிறது. அப்போது, அறிவியலாளர்களும் பொறியாளர்களும் Python-இன் எளிமையால் ஈர்க்கப்பட்டு, அதைத் தங்கள் ஆய்வுக் கணக்கீடுகளுக்குப் பயன்படுத்த விரும்பினர். ஆனால் ஒரு சிக்கல் இருந்தது. Python, இயல்பாகவே பெரிய அளவிலான எண்களைக் கொண்ட அணிகளைக் (arrays) கையாள்வதில் மிகவும் மெதுவாக இருந்தது. ஆயிரக்கணக்கான எண்களைக் கொண்ட ஒரு பட்டியலை (list) வைத்துக்கொண்டு கணிதச் செயல்பாடுகளைச் செய்வது, ஒரு ஆமை வேகப் பந்தயத்தில் ஓடுவது போல இருந்தது.

இந்தத் தடையைத் தகர்க்க, இரண்டு முக்கிய முயற்சிகள் முளைத்தன:

1. **Numeric:** இது NumPy-யின் முன்னோடி. முதன்முறையாக Python-ல் அணிகளைக் கொண்டு அறிவியல் கணக்கீடுகளைச் செய்ய வழிவகுத்தது. இது ஒரு மிகச்சிறந்த தொடக்கமாக இருந்தாலும், அதன் செயல்திறனிலும், நெகிழ்வுத்தன்மையிலும் சில குறைகள் இருந்தன.
2. **Numarray:** Numeric-இன் குறைகளைச் சரிசெய்யும் நோக்கில் இது உருவாக்கப்பட்டது. இது பெரிய அளவிலான தரவுகளைக் கையாள்வதில் சிறந்து விளங்கியது. ஆனாலும், அதன் செயல்பாடுகளிலும் சில சிக்கல்கள் நீடித்தன.

இந்த இரண்டு நூலகங்களும் பயனுள்ளதாக இருந்தபோதிலும், அவை இரண்டும் தனித்தனியாகச் செயல்பட்டதால், Python சமூகத்தில் ஒருவித குழப்பம் நிலவியது. ஒரு திட்டத்திற்கு எதைப் பயன்படுத்துவது என்ற தெளிவு இல்லாமல் இருந்தது.

##### 0.உ. NumPy-யின் உதயம்: ஒரு ஒருங்கிணைந்த சக்தி

இந்தச் சூழலில்தான், 2005-ஆம் ஆண்டு **டிராவிஸ் ஒலிஃபன்ட் (Travis Oliphant)** என்ற தொலைநோக்கு சிந்தனையாளர், இந்த இரண்டு உலகங்களின் சிறந்த அம்சங்களை ஒன்றிணைத்து, அவற்றின் குறைகளைக் களைந்து, **NumPy** என்ற ஒற்றை, சக்திவாய்ந்த நூலகத்தை உருவாக்கினார்.

NumPy-யின் இதயத்துடிப்பு என்று அழைக்கப்படுவது அதன் **ndarray (N-dimensional array)** தான். இது வெறும் ஒரு தரவு அமைப்பு அல்ல; அது ஒரு செயல்திறன் அதிசயம்.

##### 0.௩. ndarray: ஏன் இவ்வளவு சக்தி வாய்ந்தது?

Python-இன் சாதாரண `list`-ஐ ஒரு மளிகைக் கடைப் பை போல கற்பனை செய்துகொள்ளுங்கள். அதில் நீங்கள் பழம், காய்கறி, பிஸ்கட் எனப் பலதரப்பட்ட பொருட்களை வைக்கலாம். ஆனால் NumPy-யின் `ndarray` என்பது முட்டைகளை வைக்கும் அட்டைப் பெட்டி போன்றது. அதில் ஒரே மாதிரியான, ஒரே அளவிலான பொருட்களை (எண்களை) மட்டுமே வைக்க முடியும்.

இந்தக் கட்டுப்பாடுதான் அதன் மிகப்பெரிய பலம். ஒரே வகையான தரவுகள் வரிசையாக நினைவகத்தில் (memory) சேமிக்கப்படுவதால், கணினியால் மிக மிக வேகமாகச் செயல்பட முடிகிறது. ஒரு `list`-ல் உள்ள ஒவ்வொரு எண்ணுக்கும் தனித்தனியாகக் கட்டளையிடுவதற்குப் பதிலாக, NumPy-யின் `ndarray`-ஐப் பயன்படுத்தி, இலட்சக்கணக்கான எண்களைக் கொண்ட ஒரு அணிக்கு **ஒரே கட்டளையில்** ஒரு கணிதச் செயல்பாட்டைச் செய்ய முடியும். இதுதான் NumPy-யின் அபார வேகத்திற்குக் காரணம்.

இந்த **ndarray** என்ற அஸ்திவாரத்தின் மீதுதான் இன்று நாம் காணும் தரவு அறிவியல் உலகமே கட்டமைக்கப்பட்டுள்ளது. வாருங்கள், இந்த எண்களின் வேகமான உலகத்திற்குள் பயணிப்போம்!

நிச்சயமாக! நீங்கள் வழங்கிய விளக்கத்தை, வாசகர்கள் எளிதில் புரிந்து கொள்ளும் வண்ணம், மேலும் தெளிவான எடுத்துக்காட்டுகளுடன் மெருகேற்றலாம். இதோ ஒரு மேம்படுத்தப்பட்ட வடிவம்:

#### 0.௪. ஏன் நமக்கு N-பரிமாண அணிகள் தேவை?

நம்மைச் சுற்றியுள்ள உலகம் தட்டையானது அல்ல. அது நீளம், அகலம், உயரம், ஆழம், நேரம் எனப் பல பரிமாணங்களைக் கொண்டது. இந்த சிக்கலான, பல அடுக்குகள் கொண்ட உலகத்தின் தகவல்களைக் கணினிக்குப் புரியவைக்க, ஒரு எளிய பட்டியல் (list) அல்லது ஒரு சாதாரண அட்டவணை (table) போதுமானதல்ல. இங்குதான் **N-பரிமாண அணிகள் (N-dimensional arrays)** ஒரு சக்திவாய்ந்த கருவியாக நமக்கு உதவுகின்றன.

எளிமையாகச் சொன்னால், நிஜ உலகின் பல அடுக்குத் தகவல்களை, கணினி புரிந்துகொள்ளும் மொழியில் கட்டமைக்கவே நமக்கு N-பரிமாண அணிகள் தேவை. இதை இரண்டு அற்புதமான எடுத்துக்காட்டுகள் மூலம் புரிந்துகொள்வோம்.

**எடுத்துக்காட்டு 1: ஒரு புகைப்படத்திற்கு உயிர் கொடுப்பது எப்படி?**

நாம் பார்க்கும் ஒவ்வொரு டிஜிட்டல் படமும் (digital image) எண்களால் ஆன ஒரு அணிதான்.

- **கருப்பு-வெள்ளைப் படம் (Grayscale Image):** ஒரு கருப்பு-வெள்ளைப் படத்தை, சதுரங்கப் பலகை (chessboard) போலக் கற்பனை செய்துகொள்ளுங்கள். அதில் நீளம் (rows), அகலம் (columns) என இரண்டு பரிமாணங்கள் மட்டுமே இருக்கும். ஒவ்வொரு கட்டத்திலும் (pixel), கருப்பின் அடர்த்தியைக் குறிக்க ஒரு எண் இருக்கும் (உதாரணமாக, 0 என்பது முழுமையான கருப்பு, 255 என்பது முழுமையான வெள்ளை). இது ஒரு **2D அணி (2D array)**.

  - `அணியின் வடிவம்: (உயரம், அகலம்)`

- **வண்ணப் படம் (Color Image):** ஆனால், நாம் பார்க்கும் பெரும்பான்மை படங்கள் வண்ணமயமானவை. கணினியைப் பொறுத்தவரை, ஒவ்வொரு வண்ணமும் **சிவப்பு (Red), பச்சை (Green), நீலம் (Blue)** ஆகிய மூன்று அடிப்படை வண்ணங்களின் கலவையே.

  சரி, இந்தக் கூடுதல் வண்ணத் தகவலை எங்கே சேமிப்பது? இங்குதான் மூன்றாவது பரிமாணம் வருகிறது. ஒரு வண்ணப் படம் என்பது, ஒரே அளவுள்ள மூன்று 2D அணிகளை ஒன்றன் மேல் ஒன்றாக அடுக்கி வைப்பதைப் போன்றது.

  1. முதல் அடுக்கு: படத்தில் உள்ள சிவப்பு நிறத்தின் அளவைக் குறிக்கும்.
  2. இரண்டாவது அடுக்கு: பச்சை நிறத்தின் அளவைக் குறிக்கும்.
  3. மூன்றாவது அடுக்கு: நீல நிறத்தின் அளவைக் குறிக்கும்.

  இந்த மூன்று அடுக்குகளும் சேரும்போதுதான் நமக்கு ஒரு முழுமையான வண்ணப் படம் கிடைக்கிறது. எனவே, ஒரு வண்ணப் படம் என்பது ஒரு **3D அணி (3D array)**.

  - `அணியின் வடிவம்: (உயரம், அகலம், வண்ண அடுக்குகள்)`

இப்படிப் படங்களை அணிகளாக மாற்றுவதால்தான், நம்மால் ஒரு படத்தின் பிரகாசத்தை மாற்றுவது, வண்ணங்களைச் சரிசெய்வது போன்ற எண்ணற்ற Image Processing வேலைகளை எளிதாகச் செய்ய முடிகிறது.

**எடுத்துக்காட்டு 2: வானிலையைக் கணிப்பது**

ஒரு நாட்டின் வானிலை என்பது மிகவும் சிக்கலான ஒரு விஷயம். வெப்பநிலை, ஈரப்பதம், காற்றின் வேகம் எனப் பல தகவல்கள் ஒவ்வொரு இடத்திலும், ஒவ்வொரு நேரத்திலும் மாறிக்கொண்டே இருக்கும். இந்தத் தகவலை எப்படி ஒரே இடத்தில் சேமிப்பது?

யோசித்துப் பாருங்கள்:

1. **பரிமாணம் 1 & 2 (இடம்):** முதலில், ஒரு நாட்டின் வரைபடத்தை **அட்சரேகை (latitude)** மற்றும் **தீர்க்கரேகை (longitude)** கொண்டு ஒரு 2D கட்டமாக உருவாக்குகிறோம்.
2. **பரிமாணம் 3 (நேரம்):** அடுத்து, ஒரு நாளின் 24 மணிநேரத்திற்கும் தகவல்களைச் சேமிக்க வேண்டும். இது நமது மூன்றாவது பரிமாணமாக, அதாவது **நேரம்**, அமைகிறது.
3. **பரிமாணம் 4 (தரவு வகை):** இப்போது, ஒவ்வொரு இடத்திலும், ஒவ்வொரு மணி நேரத்திற்கும், நாம் வெப்பநிலை, ஈரப்பதம் போன்ற வெவ்வேறு அளவீடுகளைச் சேமிக்க வேண்டும். இது நமது நான்காவது பரிமாணம்.

ஆக, ஒரு குறிப்பிட்ட பிராந்தியத்தின் ஒரு நாள் வானிலை அறிக்கையை முழுமையாகச் சேமிக்க, நமக்கு ஒரு **4D அணி (4D array)** தேவைப்படுகிறது.

- `அணியின் வடிவம்: (அட்சரேகை இடங்கள், தீர்க்கரேகை இடங்கள், நேரம், அளவீடுகள்)`

இந்தக் கட்டமைப்பைப் பயன்படுத்துவதன் மூலம், "நேற்று மதியம் 3 மணிக்கு, நாட்டின் வடக்குப் பகுதியில் சராசரி வெப்பநிலை என்ன?" என்பது போன்ற சிக்கலான கேள்விகளுக்கு நம்மால் உடனடியாக விடை காண முடியும்.

சுருக்கமாக, **N-பரிமாண அணிகள்** என்பவை சிக்கலான நிஜ உலகத் தரவுகளைக் கையாளவும், பகுப்பாய்வு செய்யவும், அறிவியல் கணக்கீடுகளை வேகமாகவும் திறமையாகவும் செய்யவும் நமக்குக் கிடைத்த ஒரு மிகச்சிறந்த கருவியாகும்.

**குறிப்பு:**

[Array programming with NumPy](https://www.nature.com/articles/s41586-020-2649-2)

**GitHub:** https://github.com/tamil-phy/NumPy_Book_Tamil

#### அத்தியாயம் ௧: NumPy அணியின் குணாதிசயங்கள் (Array Attributes)

கற்பனை செய்துகொள்ளுங்கள், உங்களிடம் ஒரு சக்திவாய்ந்த, மர்மமான தரவுப் பெட்டி (data container) கிடைக்கிறது. அந்தப் பெட்டிக்குள் இருக்கும் பொருட்களைப் பயன்படுத்துவதற்கு முன்பு, பெட்டியைப் பற்றிய சில அடிப்படை விஷயங்களைத் தெரிந்துகொள்வது அவசியம் அல்லவா?

- அந்தப் பெட்டியின் வடிவம் என்ன? (What is its shape?)
- அது தட்டையானதா அல்லது ஆழமானதா? (Is it flat or deep?)
- உள்ளே இருக்கும் ஒவ்வொரு பொருளும் எவ்வளவு எடை கொண்டது? (How much does each item weigh?)
- அதைப் பாதுகாப்பாகக் கையாள்வதற்கான விதிகள் என்ன? (What are the handling instructions?)

NumPy-யில் நாம் உருவாக்கும் ஒவ்வொரு அணியும் (`array`) அப்படிப்பட்ட ஒரு தரவுப் பெட்டிதான். அந்த அணியின் குணாதிசயங்களை (`attributes`) விசாரிப்பது, அந்தப் பெட்டியின் மீது ஒட்டப்பட்டிருக்கும் "விவரச் சீட்டை" (`specification label`) படிப்பது போன்றது. வாருங்கள், அந்த விவரச் சீட்டில் என்னென்ன இருக்கிறது என்று பார்ப்போம்.

##### ௧.௧. `ndarray.shape` − அணியின் கட்டமைப்பு

ஒரு பெட்டியின் நீளம், அகலம், உயரம் எப்படி அதன் அளவைச் சொல்கிறதோ, அதுபோல **`shape`** (வடிவம்) என்ற குணம், ஒரு NumPy அணியின் கட்டமைப்பை நமக்குத் தெளிவாகக் காட்டுகிறது. எளிமையாகச் சொன்னால், ஓர் அணியில் **எத்தனை வரிசைகள் (`rows`)** மற்றும் **எத்தனை நிரல்கள் (`columns`)** உள்ளன என்பதைச் சொல்லும் முகவரிதான் `shape`.

**`shape`**-ஐ சோதிப்பது, நாம் எந்த மாதிரியான தரவுக் களத்தில் வேலை செய்யப் போகிறோம் என்பதைத் தெரிந்துகொள்ளும் முதல் படி.

**எடுத்துக்காட்டு:**

Python

```python
import numpy as np

# இரண்டு வரிசைகள் மற்றும் மூன்று நிரல்கள் கொண்ட ஒரு அணியை உருவாக்குவோம்
arr = np.array([[1, 2, 3], [4, 5, 6]])

print("அணியின் வடிவம் (Shape of array):", arr.shape)
```

**வெளியீடு:**

```python
அணியின் வடிவம் (Shape of array): (2, 3)
```

இந்த `(2, 3)` என்பது, நமது தரவுப் பெட்டியில் **2 வரிசைகளும்**, ஒவ்வொரு வரிசையிலும் **3 உறுப்புகளும்** உள்ளன என்பதைத் தெளிவாகக் காட்டுகிறது.

##### ௧.௨. `ndarray.ndim` − பரிமாணங்களின் எண்ணிக்கை

`shape` நமக்கு அணியின் அளவுகளைச் சொன்னால், **`ndim`** (N-Dimensions என்பதன் சுருக்கம்) அந்த அணிக்கு எத்தனை பரிமாணங்கள் (`dimensions`) உள்ளன என்பதைச் சொல்கிறது.

- `ndim = 1` என்றால், அது ஒரு தட்டையான பட்டியல் போன்ற **1D அணி**.
- `ndim = 2` என்றால், அது ஒரு அட்டவணை போன்ற **2D அணி**.
- `ndim = 3` என்றால், அது ஒன்றன் மேல் ஒன்றாக அடுக்கி வைக்கப்பட்ட பல அட்டவணைகள் போன்ற **3D அணி**.

நமது தரவுப் பெட்டி ஒரு கடிதம் போல தட்டையானதா (1D), ஒரு புகைப்படம் போல இரு பரிமாணம் கொண்டதா (2D), அல்லது ஒரு அட்டைப்பெட்டி போல முப்பரிமாணம் கொண்டதா (3D) என்பதை `ndim` ஒரு நொடியில் சொல்லிவிடும்.

**எடுத்துக்காட்டு:**

Python

```python
import numpy as np

arr = np.array([[1, 2, 3], [4, 5, 6]])

print("பரிமாணங்களின் எண்ணிக்கை (Number of dimensions):", arr.ndim)
```

**வெளியீடு:**

```python
பரிமாணங்களின் எண்ணிக்கை (Number of dimensions): 2
```

இந்த வெளியீடு, நாம் ஒரு 2D அணியுடன் (அட்டவணை போன்ற அமைப்பு) வேலை செய்கிறோம் என்பதை உறுதிப்படுத்துகிறது.

##### ௧.௩. `itemsize` − ஒவ்வொரு உறுப்பின் நினைவக அளவு

நமது தரவுப் பெட்டிக்குள் இருக்கும் ஒவ்வொரு பொருளும் ஒரே மாதிரியானவை என்று பார்த்தோம். **`itemsize`** (உறுப்பின் அளவு) என்ற குணம், அந்த அணியில் உள்ள **ஒவ்வொரு தனி உறுப்பும் (`element`)** கணினியின் நினைவகத்தில் (`memory`) எவ்வளவு இடத்தை (பைட்களில் `bytes`) எடுத்துக்கொள்கிறது என்பதைக் கூறுகிறது.

மிகப்பெரிய தரவுகளைக் கையாளும்போது, நினைவகப் பயன்பாட்டைக் கணக்கிட இந்தக் குணம் மிகவும் அவசியம்.

**எடுத்துக்காட்டு:**

Python

```python
import numpy as np

# இயல்பாக, முழு எண்கள் 64-bit integer ஆக சேமிக்கப்படும்
arr = np.array([1, 2, 3, 4, 5])

print("ஒவ்வொரு உறுப்பின் அளவு (Item size of array):", arr.itemsize, "bytes")
```

**வெளியீடு:**

```
ஒவ்வொரு உறுப்பின் அளவு (Item size of array): 8 bytes
```

இதன் பொருள், இந்த அணியில் உள்ள ஒவ்வொரு எண்ணும் கணினி நினைவகத்தில் 8 பைட்களை எடுத்துக்கொள்கிறது. இலட்சக்கணக்கான எண்களைக் கொண்ட ஒரு அணியை உருவாக்கும்போது, இந்த எண் எவ்வளவு முக்கியம் என்பது புரியும்!

##### ௧.௪. `flags` − அணியின் கையாளும் விதிகள்

ஒவ்வொரு பெட்டியின் மீதும் "Fragile" (உடையக்கூடியது), "This side up" (இந்தப் பக்கம் மேலே) போன்ற சில கையாளும் விதிமுறைகள் எழுதப்பட்டிருக்கும் அல்லவா? அதுபோல, **`flags`** (கொடிக்குறிப்புகள்) என்ற குணம், ஒரு NumPy அணியின் நினைவக அமைப்பு (`memory layout`) மற்றும் அதன் உள்ளார்ந்த பண்புகளைப் பற்றிய தொழில்நுட்ப விவரங்களைத் தருகிறது.

இது ஒரு ஆழமான தொழில்நுட்பப் பகுதி என்றாலும், இதன் மூலம் ஓர் அணி நினைவகத்தில் எவ்வாறு சேமிக்கப்பட்டுள்ளது, அதில் உள்ள தரவை நம்மால் மாற்ற முடியுமா (`writeable`) போன்ற முக்கியமான தகவல்களை அறியலாம்.

**எடுத்துக்காட்டு:**

Python

```python
import numpy as np

arr = np.array([1, 2, 3, 4, 5])

print("அணியின் கொடிக்குறிப்புகள் (Flags of the array):\n", arr.flags)
```

**வெளியீடு:**

```python
அணியின் கொடிக்குறிப்புகள் (Flags of the array):
  C_CONTIGUOUS : True
  F_CONTIGUOUS : True
  OWNDATA : True
  WRITEABLE : True
  ALIGNED : True
  WRITEBACKIFCOPY : False
```

இந்த வெளியீட்டில் உள்ள சில முக்கியக் குறிப்புகள்:

- **`C_CONTIGUOUS`**: தரவுகள் வரிசை வரிசையாக (C மொழி போல) நினைவகத்தில் தொடர்ச்சியாகச் சேமிக்கப்பட்டுள்ளன.
- **`WRITEABLE`**: `True` என இருப்பதால், இந்த அணியில் உள்ள மதிப்புகளை நம்மால் மாற்ற முடியும்.
- **`OWNDATA`**: இந்த அணி தனக்கென சொந்தமாக நினைவகத்தை ஒதுக்கியுள்ளது.

இந்தக் குணாதிசயங்கள், NumPy-யின் செயல்திறனுக்குப் பின்னால் இருக்கும் ரகசியங்களை நமக்குக் காட்டுகின்றன. ஒரு அணியின் இந்த "விவரச் சீட்டை" புரிந்துகொள்வது, அதை மேலும் திறமையாகக் கையாள நமக்கு உதவும்.

#### அத்தியாயம் ௨: NumPy அணிகளை உருவாக்கும் வழிகள் (Array Creation Routines)

ஒரு சிறந்த ஓவியத்தை வரைவதற்கு முன், ஓவியர் தனக்கு ஏற்ற கேன்வாஸைத் (canvas) தேர்ந்தெடுப்பார். சில சமயங்களில் வேக வேகமாக ஒரு ஓவியத்தை வரையத் தொடங்க, ஏற்கெனவே இருக்கும் ஒரு கேன்வாஸைப் பயன்படுத்துவார். சில சமயங்களில், முற்றிலும் புதிதாக, கறுப்பு அல்லது வெள்ளை நிறத்தில் ஒரு கேன்வாஸைத் தயார் செய்வார்.

NumPy-யிலும் அப்படித்தான். நம்முடைய தரவுப் பகுப்பாய்வு அல்லது கணக்கீடுகள் என்ற ஓவியத்தை வரைவதற்கு முன், நமக்குத் தேவையான அணியை (`array`) என்ற கேன்வாஸை உருவாக்க வேண்டும். நமது தேவைக்கேற்ப, அந்த கேன்வாஸை உருவாக்க NumPy பல எளிய வழிகளைத் தருகிறது. வாருங்கள், அவற்றில் முக்கியமான மூன்றைப் பற்றிப் பார்ப்போம்.

##### ௨.௧. `numpy.empty` − மின்னல் வேகத்தில் ஒரு தளம்

ஒரு ஓவியர் மிக அவசரமாக ஒரு ஓவியத்தை வரையத் தொடங்க வேண்டும் என்று வைத்துக்கொள்வோம். அவர் புதிதாக ஒரு கேன்வாஸை உருவாக்கக் காத்திருக்காமல், ஸ்டுடியோவில் ஏற்கெனவே இருக்கும் ஒரு கேன்வாஸை எடுத்து அப்படியே வரையத் தொடங்கிவிடுவார். அந்தப் பழைய கேன்வாஸில் ஏற்கெனவே சில கிறுக்கல்கள் இருக்கலாம், ஆனால் அவர் அதைப்பற்றிக் கவலைப்பட மாட்டார், ஏனெனில் அவர் அதன் மேல் முழுமையாகப் புதிய வண்ணங்களைப் பூசப் போகிறார்.

**`numpy.empty`** என்ற செயற்கூறு (`function`) அப்படித்தான் செயல்படுகிறது. இது ஒரு புதிய அணியை மிக மிக வேகமாக உருவாக்கும். ஆனால், அது அந்த அணிக்கான இடத்தை நினைவகத்தில் (`memory`) ஒதுக்குமே தவிர, அதில் உள்ள பழைய மதிப்புகளை நீக்காது. அதனால், அந்த இடத்தில் ஏற்கெனவே இருந்த குப்பை மதிப்புகளே (`junk values`) அந்த அணியில் இருக்கும்.

**எப்போது பயன்படுத்த வேண்டும்?** ஓர் அணியை உருவாக்கிய அடுத்த நொடியே, அதில் உள்ள எல்லா இடங்களையும் உங்கள் சொந்த மதிப்புகளைக் கொண்டு நிரப்பப் போகிறீர்கள் என்றால், தொடக்க மதிப்புகள் பற்றி உங்களுக்குக் கவலை இல்லை. அந்தச் சமயத்தில், வேகத்திற்காக `numpy.empty`-ஐப் பயன்படுத்தலாம்.

**எடுத்துக்காட்டு:**

Python

```python
import numpy as np

# 2 வரிசை, 3 நிரல்களுடன் ஒரு காலி அணியை உருவாக்குதல்
empty_array = np.empty((2, 3))

print("காலி அணி (Empty array):\n", empty_array)
```

**வெளியீடு:**

```python
காலி அணி (Empty array):
 [[2.12199579e-314 6.36598737e-315 8.48798316e-315]
 [1.06099790e-314 1.27319747e-314 1.48539705e-314]]
```

**கவனம்:** ⚠️ இங்கு வரும் மதிப்புகள் ஒவ்வொரு முறையும் மாறக்கூடியவை. இவை கணினியின் நினைவகத்தில் அந்த நேரத்தில் இருந்த தேவையற்ற மதிப்புகள். இந்த அணியின் மதிப்புகளை நம்பி எந்தக் கணக்கீட்டையும் செய்யக்கூடாது.

##### ௨.௨. `numpy.zeros` − ஒரு சுழியத் தொடக்கம்

சில சமயங்களில், ஓவியர் தன் ஓவியத்தை ஒரு முழுமையான கறுப்பு நிறப் பின்னணியில் இருந்து தொடங்க விரும்புவார். அது ஓவியத்திற்கு ஒரு புதிய பரிமாணத்தைக் கொடுக்கும்.

**`numpy.zeros`** என்ற செயற்கூறு, அப்படிப்பட்ட ஒரு கறுப்பு கேன்வாஸை நமக்குத் தருகிறது. இது நாம் கேட்கும் வடிவில் (`shape`) ஓர் அணியை உருவாக்கி, அதன் அனைத்து உறுப்புகளையும் (`elements`) **சுழியம் (`0`)** என்ற மதிப்பைக் கொண்டு நிரப்பும். இது மிகவும் பாதுகாப்பான மற்றும் கணிக்கக்கூடிய ஒரு தொடக்கத்தைத் தருகிறது.

**எப்போது பயன்படுத்த வேண்டும்?** நீங்கள் ஒரு கணக்கீட்டின் தொடக்க மதிப்பை சுழியத்திலிருந்து தொடங்க விரும்பும்போது, (உதாரணமாக, மதிப்பெண்களைக் கூட்டத் தொடங்கும் முன் மொத்த மதிப்பை 0 என வைப்பது போல) `numpy.zeros` மிகவும் பயனுள்ளதாக இருக்கும்.

**எடுத்துக்காட்டு:**

Python

```python
import numpy as np

# 2x2 வடிவில் சுழியங்கள் நிறைந்த அணியை உருவாக்குதல்
zeros_array = np.zeros((2, 2))

print("சுழிய அணி (Zeros array):\n", zeros_array)
```

**வெளியீடு:**

```python
சுழிய அணி (Zeros array):
 [[0. 0.]
 [0. 0.]]
```

பார்த்தீர்களா? எந்தக் குழப்பமும் இல்லாத, சுத்தமான, கணிக்கக்கூடிய ஒரு தொடக்கம்.

##### ௨.௩. `numpy.ones` − ஒன்றிலிருந்து தொடங்குவோம்

சில கணக்கீடுகளுக்கு, நமக்கு சுழியம் ஒரு நல்ல தொடக்கமாக இருக்காது. பெருக்கல் போன்ற சில கணிதச் செயல்பாடுகளுக்கு, தொடக்க மதிப்பை `1` என வைப்பது பயனுள்ளதாக இருக்கும். இதை, ஓவியர் தன் கேன்வாஸை வெள்ளை நிறப் பின்னணியில் இருந்து தொடங்குவதுடன் ஒப்பிடலாம்.

**`numpy.ones`** என்ற செயற்கூறு, நாம் கேட்கும் வடிவில் ஓர் அணியை உருவாக்கி, அதன் அனைத்து உறுப்புகளையும் **ஒன்று (`1`)** என்ற மதிப்பைக் கொண்டு நிரப்புகிறது.

**எடுத்துக்காட்டு:**

Python

```python
import numpy as np

# 3x3 வடிவில் ஒன்றுகள் நிறைந்த அணியை உருவாக்குதல்
ones_array = np.ones((3, 3))

print("ஒன்று அணி (Ones array):\n", ones_array)
```

**வெளியீடு:**

```python
ஒன்று அணி (Ones array):
 [[1. 1. 1.]
 [1. 1. 1.]
 [1. 1. 1.]]
```

சுருக்கமாகச் சொன்னால், உங்கள் தேவைக்கேற்ப சரியான கேன்வாஸைத் தேர்ந்தெடுங்கள்:

- **அதிகபட்ச வேகம் தேவையெனில்:** `np.empty()` (பயன்படுத்திய கேன்வாஸ்)
- **பாதுகாப்பான, சுழியத் தொடக்கம் தேவையெனில்:** `np.zeros()` (கறுப்பு கேன்வாஸ்)
- **குறிப்பிட்ட, ஒன்றென்ற தொடக்கம் தேவையெனில்:** `np.ones()` (வெள்ளை கேன்வாஸ்)



#### அத்தியாயம் ௩: NUMPY − ARRAY FROM EXISTING DATA (ஏற்கெனவே உள்ள தரவிலிருந்து ஓர் அணியை உருவாக்குதல்)

ஒரு திறமையான சிற்பி, தன்னிடம் வரும் மூலப்பொருட்கள் எந்த வடிவில் இருந்தாலும்—அது ஒரு பாறையாக இருந்தாலும், மரத்துண்டாக இருந்தாலும், அல்லது உடைந்த சிலைகளின் பாகங்களாக இருந்தாலும்—அதை நேர்த்தியாகச் செதுக்கி ஒரு அற்புதமான சிற்பமாக மாற்றுவார்.

NumPy-யும் அப்படித்தான். நம்முடைய தரவுகள் Python-ல் பல வடிவங்களில் இருக்கலாம். ஒரு சாதாரணமான பட்டியல் (`list`), கணினியின் நினைவகத்தில் இருக்கும் ஒரு மூலத் தரவுப் பகுதி (`buffer`), அல்லது தேவைக்கேற்ப மதிப்புகளை உருவாக்கும் ஒரு நீரோடை (`iterable`) என எப்படி இருந்தாலும், NumPy அவற்றை சக்திவாய்ந்த அணிகளாக (`arrays`) மாற்றும் கருவிகளைக் கொண்டுள்ளது.

இந்த அத்தியாயத்தில், வெவ்வேறு மூலப்பொருட்களை NumPy என்ற சிற்பி எப்படித் தனக்கு ஏற்றவாறு செதுக்கிக் கொள்கிறார் என்று பார்ப்போம்.

##### ௩.௧. `numpy.asarray` − மளிகைப் பையிலிருந்து மாற்றுதல்

நம்மிடம் இருக்கும் தரவுகளில் மிகவும் பொதுவானது Python `list`. இதை ஒரு மளிகைப் பை (`grocery bag`) என்று கற்பனை செய்துகொள்ளுங்கள். **`asarray`** என்ற செயற்கூறு (`function`), அந்தப் பையில் இருக்கும் பொருட்களை எடுத்து, நேர்த்தியாக NumPy என்ற பாத்திரத்தில் வைக்கும் ஒரு புத்திசாலியான வேலையாள்.

இதன் மிகப்பெரிய சிறப்பு என்னவென்றால், நீங்கள் கொடுக்கும் பொருள் ஏற்கெனவே ஒரு NumPy பாத்திரத்தில் (அணியில்) இருந்தால், இந்த வேலையாள் அதை மீண்டும் ஒரு புதிய பாத்திரத்திற்கு மாற்ற மாட்டார். இதனால், தேவையற்ற நகல் எடுப்பது தவிர்க்கப்பட்டு, நினைவகம் (`memory`) சேமிக்கப்படுகிறது.

**எடுத்துக்காட்டு:**

Python

```python
import numpy as np

# நமது மளிகைப் பை (Python list)
list_data = [10, 20, 30, 40, 50]

# அதை NumPy பாத்திரத்திற்கு (array) மாற்றுவோம்
array_data = np.asarray(list_data)

print("பட்டியலிலிருந்து உருவான அணி (Array from list):", array_data)
print("அணியின் வகை (Type of array):", type(array_data))
```

**வெளியீடு:**

```python
பட்டியலிலிருந்து உருவான அணி (Array from list): [10 20 30 40 50]
அணியின் வகை (Type of array): <class 'numpy.ndarray'>
```

சாதாரண `list`-ஆக இருந்தது, இப்போது NumPy-யின் சக்திவாய்ந்த செயல்பாடுகளுக்குத் தயாராகிவிட்டது.

##### ௩.௨. `numpy.frombuffer` − மூலப் பொட்டலத்தைப் பிரித்தல்

சில சமயங்களில், தரவுகள் நமக்கு நேரடியாகப் புரியும் வடிவில் இருக்காது. அவை கணினியின் நினைவகத்தில் பைனரி (`binary`) வடிவில், அதாவது ஒருவித மூலக் குறியீடு போல, ஒரு பொட்டலத்தில் (`buffer`) அடைக்கப்பட்டிருக்கும்.

**`frombuffer`** என்ற கருவி, அந்தப் பொட்டலத்தைப் பிரித்து, உள்ளே இருக்கும் மூலத் தரவை நாம் குறிப்பிடும் வடிவில் (எடுத்துக்காட்டாக, ஒவ்வொரு எழுத்தாக) தனித்தனி உறுப்புகளாக மாற்றி ஓர் அணியை உருவாக்கும் ஒரு சிறப்பு நிபுணர். இது பெரும்பாலும் கோப்புகளைப் படிக்கும்போதும், பிணையத் தரவுகளைக் கையாளும்போதும் பயன்படும்.

**எடுத்துக்காட்டு:**

Python

```python
import numpy as np

# b'...' என்பது ஒரு பைனரி தரவுப் பொட்டலம்
buffer_data = b'Gemini AI'

# அந்தப் பொட்டலத்தை ஒவ்வொரு எழுத்தாக ('S1') பிரிக்கச் சொல்கிறோம்
array_buffer = np.frombuffer(buffer_data, dtype='S1')

print("பொட்டலத்திலிருந்து உருவான அணி (Array from buffer):", array_buffer)
```

**வெளியீடு:**

```python
பொட்டலத்திலிருந்து உருவான அணி (Array from buffer):
 [b'G' b'e' b'm' b'i' b'n' b'i' b' ' b'A' b'I']
```

பார்த்தீர்களா, `frombuffer` அந்த மூலப் பொட்டலத்தை நேர்த்தியாகப் பிரித்து, ஒவ்வொரு உறுப்பையும் தனித்தனியாகக் கொடுத்துவிட்டது.

##### ௩.௩. `numpy.fromiter` − நீரோடையிலிருந்து சேகரித்தல்

சில நேரங்களில், நமக்குத் தேவையான எல்லாத் தரவுகளும் ஒரே நேரத்தில் கிடைக்காது. அவை ஒரு நீரோடை (`stream`) அல்லது நகரும் பட்டை (`conveyor belt`) போல, தேவைக்கேற்ப ஒவ்வொன்றாக வந்து கொண்டிருக்கும். இப்படிப்பட்ட `iterable` அல்லது `generator` வகை தரவுகளைக் கையாளவே **`fromiter`** என்ற செயற்கூறு உதவுகிறது.

இது மிகவும் நினைவகத் திறன்கொண்டது (`memory-efficient`). ஏனெனில், இது எல்லாத் தரவுகளும் வரும் வரை காத்திருந்து ஒரு பெரிய பட்டியலை உருவாக்காது. மாறாக, நீரோடையில் இருந்து வரும் ஒவ்வொரு மதிப்பையும் உடனடியாக எடுத்து, நேராக NumPy அணிக்குள் சேகரித்துவிடும்.

**எடுத்துக்காட்டு:**

range(5)-ல் உள்ள ஒவ்வொரு எண்ணையும் இரண்டால் பெருக்கி வரும் மதிப்புகளைக் கொண்ட ஒரு நீரோடையை (iterable) உருவாக்குவோம்.

Python

```python
import numpy as np

# இது ஒரு நீரோடை. மதிப்புகள் தேவைப்படும்போது மட்டுமே உருவாகும்.
iterable_data = (x * 2 for x in range(5))

# fromiter, அந்த ஓடையில் இருந்து மதிப்புகளைச் சேகரிக்கிறது
array_iter = np.fromiter(iterable_data, dtype='int32')

print("நீரோடையிலிருந்து உருவான அணி (Array from iterable):", array_iter)
```

**வெளியீடு:**

```python
நீரோடையிலிருந்து உருவான அணி (Array from iterable): [0 2 4 6 8]
```

`fromiter` அந்த நீரோடையில் இருந்து ஒவ்வொரு மதிப்பாக (0, 2, 4, 6, 8) எடுத்து, ஒரு முழுமையான NumPy அணியை உருவாக்கிவிட்டது.

**சுருக்கம்: சரியான கருவியைத் தேர்ந்தெடுங்கள்**

| செயற்கூறு (Function) | உவமை (Analogy)              | எப்போது பயன்படுத்த வேண்டும்?                                 |
| ------------------- | --------------------------- | ------------------------------------------------------- |
| `np.asarray()`      | மளிகைப் பை (Grocery Bag)     | Python `list` அல்லது `tuple`-களை மாற்ற. (நினைவகச் சிக்கனம்)  |
| `np.frombuffer()`   | மூலப் பொட்டலம் (Sealed Packet) | பைனரி (`binary`) தரவுகளைக் கையாள. (மேம்பட்ட பயன்பாடு)       |
| `np.fromiter()`     | நகரும் பட்டை (Conveyor Belt)  | `iterable`-களை நினைவகத் திறனுடன் மாற்ற. (பெரிய தரவுகளுக்கு) |

#### அத்தியாயம் ௪: NUMPY − ARRAY FROM NUMERICAL RANGES  (எண் வரம்புகளிலிருந்து ஓர் அணியை உருவாக்குதல்)

தரவு அறிவியலில் பல நேரங்களில், நம்மிடம் தரவுகள் இருக்காது; மாறாக, நாமே ஒரு எண் தொடரை (`sequence of numbers`) உருவாக்க வேண்டியிருக்கும். இதை ஒரு நீண்ட பாதையில், குறிப்பிட்ட இடங்களில் கற்களை வைப்பதற்கு ஒப்பிடலாம். பாதையின் தொடக்கம் எங்கே, முடிவு எங்கே, ஒவ்வொரு கல்லுக்கும் எவ்வளவு இடைவெளி இருக்க வேண்டும் என்பதை நாம்தான் தீர்மானிக்க வேண்டும்.

NumPy, இப்படிப்பட்ட எண் பாதைகளை உருவாக்க மூன்று விதமான கருவிகளை நமக்குத் தருகிறது. ஒவ்வொன்றும் ஒரு குறிப்பிட்ட முறையில் கற்களை வைப்பதற்கு உதவுகிறது.

##### ௪.௧. `numpy.arange` − குறிப்பிட்ட இடைவெளியில் கல் வைத்தல்

இது பாதையில் கல் வைப்பதற்கான மிகவும் நேரடியான முறை. **`arange`** (Arrange என்பதன் சுருக்கம்) என்ற கருவியைப் பயன்படுத்தும்போது, நீங்கள் மூன்று விஷயங்களைக் குறிப்பிடுவீர்கள்:

1. **தொடக்கம் (`start`):** முதல் கல்லை எங்கே வைக்க வேண்டும்?
2. **முடிவு (`stop`):** எந்த இடத்திற்கு முன்புவரை கற்களை வைக்க வேண்டும்?
3. **இடைவெளி (`step`):** ஒவ்வொரு கல்லுக்கும் இடையில் எவ்வளவு தூரம் இருக்க வேண்டும்?

இது Python-ல் உள்ள `range()` செயற்கூறு போன்றதே. ஆனால் இது மிதக்கும் புள்ளி எண்களையும் (`floating point numbers`) கையாளும் மற்றும் NumPy அணியை உருவாக்கும்.

எடுத்துக்காட்டு:

1-லிருந்து தொடங்கி, 10-க்குள், ஒவ்வொரு கல்லுக்கும் 2 அடி இடைவெளி விட்டு வைப்போம்.

Python

```python
import numpy as np

# arange(தொடக்கம், முடிவு, இடைவெளி)
array_arange = np.arange(1, 10, 2)

print("arange மூலம் உருவான அணி:", array_arange)
```

**வெளியீடு:**

```python
arange மூலம் உருவான அணி: [1 3 5 7 9]
```

பார்த்தீர்களா? 1-ல் தொடங்கி, ஒவ்வொரு முறையும் 2 அடி இடைவெளி விட்டு, 10-ஐத் தாண்டுவதற்கு முன்புவரை கற்கள் அழகாக அடுக்கப்பட்டுவிட்டன.

##### ௪.௨. `numpy.linspace` − சமமான எண்ணிக்கையில் கல் வைத்தல்

இப்போது, முறையைச் சற்று மாற்றுவோம். எவ்வளவு இடைவெளி என்பதைக் குறிப்பிடாமல், ஒரு பாதையின் தொடக்கத்தையும் முடிவையும் சொல்லி, **"சரியாக இத்தனை கற்களை மட்டும் சமமான இடைவெளியில் வைக்க வேண்டும்"** என்று கூறினால் எப்படி? அதுதான் **`linspace`** (Linearly Spaced என்பதன் சுருக்கம்) செய்யும் வேலை.

நீங்கள் குறிப்பிடும் எண்ணிக்கையில் கற்களை சமமான இடைவெளியில் வைக்க, ஒவ்வொரு கல்லுக்கும் எவ்வளவு இடைவெளி தேவை என்பதை `linspace` தானாகவே கணக்கிட்டுக் கொள்ளும்.

**முக்கிய குறிப்பு:** `arange` போலல்லாமல், `linspace` **முடிவு மதிப்பையும் (`stop` value) அணியில் சேர்த்துக்கொள்ளும்**.

எடுத்துக்காட்டு:

0-விலிருந்து 10 மீட்டர் நீளமுள்ள ஒரு பாதையில், சரியாக 5 கற்களை சமமான இடைவெளியில் வைப்போம்.

Python

```python
import numpy as np

# linspace(தொடக்கம், முடிவு, கற்களின் எண்ணிக்கை)
array_linspace = np.linspace(0, 10, 5)

print("linspace மூலம் உருவான அணி:", array_linspace)
```

**வெளியீடு:**

```python
linspace மூலம் உருவான அணி: [ 0.   2.5  5.   7.5 10. ]
```

0-விற்கும் 10-க்கும் இடையில் 5 கற்களை சமமாக அடுக்க, ஒவ்வொரு கல்லுக்கும் 2.5 மீட்டர் இடைவெளி தேவை என்பதை `linspace` தானாகவே கணக்கிட்டு, கற்களை வைத்துவிட்டது.

##### ௪.௩. `numpy.logspace` − அதிவேகமாக கல் வைத்தல்

சில நேரங்களில், பாதையின் தொடக்கத்தில் கற்களை நெருக்கமாகவும், போகப்போக கற்களின் இடைவெளியை அதிவேகமாக (exponentially) அதிகரித்துக்கொண்டே செல்ல வேண்டியிருக்கும். இதை ஒரு ராக்கெட் கிளம்புவது போல கற்பனை செய்துகொள்ளுங்கள்; முதலில் மெதுவாகவும், பின்னர் மிக வேகமாகவும் பயணிக்கும்.

**`logspace`** (Logarithmically Spaced என்பதன் சுருக்கம்) இந்த வேலையைச் செய்கிறது. இது மடக்கை அளவில் (`logarithmic scale`) சமமான இடைவெளியில் எண்களை உருவாக்கும். இது அதிர்வெண் பகுப்பாய்வு (`frequency analysis`) போன்ற அறிவியல் கணக்கீடுகளில் மிகவும் பயனுள்ளதாக இருக்கும்.

சுருக்கமாக, `logspace(1, 3, 5)` என்றால், 101-க்கும் 103-க்கும் இடையில், மடக்கை அளவில் 5 சம இடைவெளிகளை உருவாக்கு என்று பொருள்.

எடுத்துக்காட்டு:

101 (10) க்கும் 103 (1000) க்கும் இடையில் 5 கற்களை மடக்கை அளவில் வைப்போம்.

Python

```python
import numpy as np

# logspace(தொடக்கம்^, முடிவு^, எண்ணிக்கை) -> 10^1, 10^3
array_logspace = np.logspace(1, 3, 5)

print("logspace மூலம் உருவான அணி:", array_logspace)
```

**வெளியீடு:**

```python
logspace மூலம் உருவான அணி: [   10.           31.6227766   100.          316.22776602 1000.        ]
```

இங்கே, தொடக்கத்தில் இடைவெளி குறைவாகவும் (10-க்கும் 31-க்கும் இடையில்), போகப்போக இடைவெளி அதிவேகமாக அதிகரிப்பதையும் (316-க்கும் 1000-க்கும் இடையில்) காணலாம்.

**சுருக்கம்: எந்தக் கருவி எப்போது?**

| செயற்கூறு (Function) | மையக்கரு (Core Idea)                               | எதைக் கட்டுப்படுத்துகிறோம்?                        |
| ------------------- | ------------------------------------------------- | --------------------------------------------- |
| `np.arange()`       | குறிப்பிட்ட படி அளவு (Fixed Step Size)              | ஒவ்வொரு படிக்கும் உள்ள **இடைவெளியை**.             |
| `np.linspace()`     | குறிப்பிட்ட படிகளின் எண்ணிக்கை (Fixed Number of Steps) | பாதையில் வைக்கப்படும் **மொத்த படிகளின் எண்ணிக்கையை**. |
| `np.logspace()`     | அதிவேகப் படிகள் (Exponential Steps)                 | பரந்த எண் வரம்பை (பல மடங்கு மதிப்புகள்) ஆராய.       |



#### அத்தியாயம் ௫: NumPy − உங்களுக்குத் தேவையானதைத் தேர்ந்தெடுத்தல் (Indexing & Slicing)

ஒரு பெரிய நூலக அலமாரியில் (`bookshelf`) ஆயிரக்கணக்கான புத்தகங்கள் வரிசையாக அடுக்கப்பட்டிருப்பதாகக் கற்பனை செய்துகொள்ளுங்கள். NumPy அணி என்பதும் அப்படியான ஒரு நேர்த்தியான அலமாரிதான். இப்போது, அந்த அலமாரியிலிருந்து உங்களுக்குத் தேவையான புத்தகங்களை எப்படி எடுப்பீர்கள்?

- **ஒரு குறிப்பிட்ட புத்தகம் வேண்டுமானால்:** அதன் சரியான இடத்தைச் சொல்லி எடுப்பீர்கள். (உதாரணமாக, "மேலிருந்து இரண்டாவது வரிசையில், இடமிருந்து ஐந்தாவது புத்தகம்").
- **ஒரு பகுதி புத்தகங்கள் வேண்டுமானால்:** "இந்த வரிசையில் உள்ள 3-வது புத்தகத்திலிருந்து 7-வது புத்தகம் வரை அனைத்தையும் கொடு" என்று கேட்பீர்கள்.

இந்த இரண்டு வழிகள்தான் NumPy-யில் **Indexing** மற்றும் **Slicing**. இது தரவுகளைப் பிரித்தெடுப்பதற்கும், கையாளுவதற்கும் மிகவும் அடிப்படையான மற்றும் சக்திவாய்ந்த முறையாகும்.

##### ௫.௧. ஒரு வரிசை அலமாரி (1D Array) – அடிப்படைகள்

முதலில், ஒரே ஒரு வரிசை கொண்ட எளிய அலமாரியைப் பார்ப்போம்.

Python

```python
import numpy as np

# நமது ஒற்றை வரிசை அலமாரி
arr = np.array([10, 20, 30, 40, 50, 60])
```

##### ௫.௨. Indexing: ஒரு குறிப்பிட்ட புத்தகத்தை எடுத்தல்

அலமாரியில் உள்ள ஒரு குறிப்பிட்ட புத்தகத்தை அதன் வரிசை எண்ணைச் சொல்லி எடுப்பதே **Indexing**.

**மிக முக்கியமான விதி:** NumPy (மற்றும் பெரும்பாலான நிரலாக்க மொழிகளில்) எண்ணுவது `0`-விலிருந்து தொடங்கும். எனவே, முதல் புத்தகம் `0`-வது இடத்திலும், இரண்டாவது புத்தகம் `1`-வது இடத்திலும் இருக்கும்.

Python

```python
# 3-வது இடத்தில் (index 2) உள்ள புத்தகத்தை எடுப்போம்
print("3-வது இடத்தில் உள்ள உறுப்பு:", arr[2])

# கடைசிப் புத்தகத்தை எடுக்க ஒரு தந்திரம்: எதிர்மறை குறியீடு (negative index)
print("கடைசி உறுப்பு:", arr[-1])
print("கடைசியிலிருந்து இரண்டாவது உறுப்பு:", arr[-2])
```

**வெளியீடு:**

```python
3-வது இடத்தில் உள்ள உறுப்பு: 30
கடைசி உறுப்பு: 60
கடைசியிலிருந்து இரண்டாவது உறுப்பு: 50
```

##### ௫.௩. Slicing: ஒரு பகுதி புத்தகங்களை எடுத்தல்

அலமாரியின் ஒரு குறிப்பிட்ட பகுதியை அப்படியே வெட்டி எடுப்பதே **Slicing**. இதற்கு `[தொடக்கம் : முடிவு]` என்ற வடிவமைப்பைப் பயன்படுத்துவோம்.

**மிக முக்கியமான விதி:** `முடிவு` (`stop`) என்று குறிப்பிடும் இடத்திற்கு **முந்தைய இடம் வரை** மட்டுமே உறுப்புகள் எடுக்கப்படும். `arr[1:4]` என்றால், 1-வது இடத்திலிருந்து தொடங்கி, 4-வது இடத்திற்கு முன்புவரை (அதாவது 1, 2, 3) உள்ள உறுப்புகளை எடு என்று பொருள்.

Python

```python
# 2-வது இடத்திலிருந்து (index 1) 5-வது இடத்திற்கு (index 4) முன்புவரை எடுப்போம்
print("ஒரு பகுதி (Slice):", arr[1:4])

# தொடக்கத்திலிருந்து 3-வது இடம் வரை
print("தொடக்கத்திலிருந்து ஒரு பகுதி:", arr[:3])

# 3-வது இடத்திலிருந்து கடைசி வரை
print("ஒரு இடத்திலிருந்து கடைசி வரை:", arr[2:])
```

**வெளியீடு:**

```python
ஒரு பகுதி (Slice): [20 30 40]
தொடக்கத்திலிருந்து ஒரு பகுதி: [10 20 30]
ஒரு இடத்திலிருந்து கடைசி வரை: [30 40 50 60]
```

##### ௫.௪. பல அடுக்கு அலமாரி (2D Array) – உண்மையான சக்தி

NumPy-யின் உண்மையான பலம், பல அடுக்குகள் கொண்ட அலமாரிகளை (2D அணிகளை) கையாளும்போதுதான் வெளிப்படுகிறது. இங்கே ஒரு புத்தகத்தை எடுக்க, அது **எந்த வரிசையில் (row)**, **எந்த இடத்தில் (column)** இருக்கிறது என்று சொல்ல வேண்டும்.

Python

```python
# 3 வரிசைகள், 4 நிரல்கள் கொண்ட பல அடுக்கு அலமாரி
bookcase = np.array([[10, 11, 12, 13],
                     [20, 21, 22, 23],
                     [30, 31, 32, 33]])
```

**ஒரு குறிப்பிட்ட உறுப்பை எடுத்தல்**

`[வரிசை, நிரல்]` என்ற குறியீட்டைப் பயன்படுத்துவோம்.

Python

```python
# 2-வது வரிசையில் (index 1), 3-வது இடத்தில் (index 2) உள்ள புத்தகம்
element = bookcase[1, 2]
print("குறிப்பிட்ட உறுப்பு:", element)  # வெளியீடு: 22
```

**ஒரு முழு வரிசையை (Row) எடுத்தல்**

ஒரு வரிசையில் உள்ள அனைத்துப் புத்தகங்களையும் எடுக்க, நிரல் (`column`) இடத்தில் `:` குறியீட்டைப் பயன்படுத்தவும்.

Python

```python
# 2-வது வரிசையை (index 1) முழுமையாக எடுப்போம்
row_slice = bookcase[1, :]
print("ஒரு முழு வரிசை:", row_slice)  # வெளியீடு: [20 21 22 23]
```

**ஒரு முழு நிரலை (Column) எடுத்தல்**

அலமாரியில் உள்ள ஒவ்வொரு வரிசையிலிருந்தும், ஒரு குறிப்பிட்ட இடத்தில் உள்ள புத்தகத்தை மட்டும் எடுக்க, வரிசை (`row`) இடத்தில் `:` குறியீட்டைப் பயன்படுத்தவும்.

Python

```python
# 3-வது நிரலை (index 2) முழுமையாக எடுப்போம்
col_slice = bookcase[:, 2]
print("ஒரு முழு நிரல்:", col_slice)  # வெளியீடு: [12 22 32]
```

**ஒரு பகுதி அலமாரியை எடுத்தல் (Sub-matrix)**

அலமாரியின் ஒரு குறிப்பிட்ட செவ்வகப் பகுதியை வெட்டி எடுக்கலாம்.

Python

```python
# முதல் இரண்டு வரிசைகளில், 2-வது மற்றும் 3-வது நிரல்களை எடுப்போம்
sub_matrix = bookcase[0:2, 1:3]
print("ஒரு பகுதி அலமாரி:\n", sub_matrix)
```

**வெளியீடு:**

```python
ஒரு பகுதி அலமாரி:
 [[11 12]
 [21 22]]
```

Indexing மற்றும் Slicing-ல் தேர்ச்சி பெறுவது, NumPy-யில் தரவுகளைக் கையாள்வதற்கான திறவுகோல். இதன் மூலம், எவ்வளவு பெரிய தரவுக் கட்டமைப்பாக இருந்தாலும், நமக்குத் தேவையான பகுதியைத் துல்லியமாகப் பிரித்தெடுக்க முடியும்.



#### அத்தியாயம் ௬: NumPy − மேம்பட்ட தேர்வு முறைகள் (Advanced Indexing)

கடந்த அத்தியாயத்தில், நமது நூலக அலமாரியிலிருந்து ஒரு குறிப்பிட்ட புத்தகத்தையோ (`Indexing`) அல்லது ஒரு நேர்த்தியான பகுதிப் புத்தகங்களையோ (`Slicing`) எப்படி எடுப்பது என்று பார்த்தோம்.

ஆனால், உங்கள் தேவை இன்னும் சிக்கலானதாக இருந்தால் என்ன செய்வது?

- "முதல் வரிசையில் 2-வது புத்தகம், மூன்றாவது வரிசையில் 4-வது புத்தகம், இரண்டாவது வரிசையில் 1-வது புத்தகம் வேண்டும்" என்று **ஒரே நேரத்தில் பல இடங்களில் இருந்து** புத்தகங்களைக் கேட்க வேண்டுமானால்?
- "இந்த அலமாரியில், 500 பக்கங்களுக்கு மேல் உள்ள எல்லாப் புத்தகங்களையும் கொடுங்கள்" என்று **ஒரு நிபந்தனையின் அடிப்படையில்** புத்தகங்களைத் தேர்ந்தெடுக்க வேண்டுமானால்?

இப்படிப்பட்ட சிக்கலான தேர்வுகளைச் செய்வதற்கான மந்திரக் கருவிகள்தான் **மேம்பட்ட தேர்வு முறைகள் (Advanced Indexing)**.

##### ௬.௧. Integer Array Indexing − உங்கள் விருப்பத் தேர்வுப் பட்டியல்

இது நூலகரிடம் ஒரு **தனிப்பயன் தேர்வுப் பட்டியலைக் (custom shopping list)** கொடுப்பது போன்றது. அந்தப் பட்டியலில், உங்களுக்குத் தேவையான புத்தகங்களின் வரிசை மற்றும் நிரல் எண்களை (`row` and `column` coordinates) துல்லியமாகக் குறிப்பிடுவீர்கள். நூலகர் (NumPy) அந்தப் பட்டியலைப் பார்த்து, அலமாரியின் வெவ்வேறு மூலைகளில் இருக்கும் அந்தப் புத்தகங்களை மட்டும் உங்களுக்காக எடுத்து வருவார்.

எடுத்துக்காட்டு:

நம்மிடம் உள்ள பல அடுக்கு அலமாரியிலிருந்து, குறிப்பிட்ட மூன்று புத்தகங்களை ஒரே நேரத்தில் எடுப்போம்.

Python

```python
import numpy as np

# நமது பல அடுக்கு அலமாரி
bookcase = np.array([[10, 11, 12, 13],
                     [20, 21, 22, 23],
                     [30, 31, 32, 33]])

# நமது தேர்வுப் பட்டியல்:
# நமக்கு வேண்டிய புத்தகங்களின் வரிசை எண்கள்: [0, 2, 1]
# நமக்கு வேண்டிய புத்தகங்களின் நிரல் எண்கள்:  [1, 3, 0]
rows = [0, 2, 1]
cols = [1, 3, 0]

# முதல் தேர்வு: வரிசை 0, நிரல் 1 -> 11
# இரண்டாம் தேர்வு: வரிசை 2, நிரல் 3 -> 33
# மூன்றாம் தேர்வு: வரிசை 1, நிரல் 0 -> 20

# பட்டியலை NumPy-யிடம் கொடுப்போம்
selected_books = bookcase[rows, cols]

print("தேர்வுப் பட்டியலிலிருந்து கிடைத்தவை:", selected_books)
```

**வெளியீடு:**

```python
தேர்வுப் பட்டியலிலிருந்து கிடைத்தவை: [11 33 20]
```

ஒரே கட்டளையில், அலமாரியின் வெவ்வேறு இடங்களில் இருந்த புத்தகங்களை நம்மால் துல்லியமாகத் தேர்ந்தெடுக்க முடிந்தது. இதுதான் Integer Array Indexing-இன் சக்தி.

##### ௬.௨. Boolean Array Indexing − மந்திர வடிப்பான்

இது ஒரு மிகவும் சக்திவாய்ந்த முறை. இதை அலமாரியின் மீது வைக்கும் ஒரு **மந்திர வடிப்பானுக்கு (magical filter)** ஒப்பிடலாம். நீங்கள் ஒரு நிபந்தனையை உருவாக்குவீர்கள். அந்த நிபந்தனை, அலமாரியில் உள்ள ஒவ்வொரு புத்தகத்தின் மீதும் சோதிக்கப்படும்.

1. **நிபந்தனை (Condition):** முதலில், "25-ஐ விட பெரிய எண்கள் எவை?" என்பது போன்ற ஒரு நிபந்தனையை உருவாக்குவோம்.
2. **வடிப்பான் உருவாதல் (Mask Creation):** NumPy, இந்த நிபந்தனையை ஒவ்வொரு உறுப்பின் மீதும் செலுத்தி, `True` (நிபந்தனை சரி) அல்லது `False` (நிபந்தனை தவறு) என்ற மதிப்புகள் கொண்ட ஒரு புதிய அணியை (வடிப்பானை) உருவாக்கும்.
3. **வடித்தெடுத்தல் (Filtering):** இந்த வடிப்பானை அசல் அணியின் மீது செலுத்தும்போது, `True` என்று குறிக்கப்பட்ட இடங்களில் உள்ள உறுப்புகள் மட்டுமே நமக்குக் கிடைக்கும்.

எடுத்துக்காட்டு:

நம் அலமாரியில், 25-ஐ விட பெரிய மதிப்புகள் கொண்ட புத்தகங்களை மட்டும் எடுப்போம்.

Python

```python
# நமது அலமாரி
arr = np.array([[10, 20, 30],
                [40, 25, 15],
                [50, 60, 22]])

# படி 1: நிபந்தனையை உருவாக்குதல்
condition = arr > 25
print("மந்திர வடிப்பான் (Boolean Mask):\n", condition)

# படி 2: வடிப்பானைப் பயன்படுத்துதல்
filtered_array = arr[condition]
print("\nவடித்தெடுத்த பின் கிடைத்தவை:", filtered_array)
```

**வெளியீடு:**

```python
மந்திர வடிப்பான் (Boolean Mask):
 [[False False  True]
 [ True False False]
 [ True  True False]]

வடித்தெடுத்த பின் கிடைத்தவை: [30 40 50 60]
```

`True` என்று எங்கெல்லாம் இருந்ததோ, அந்த இடங்களில் உள்ள மதிப்புகள் (`30, 40, 50, 60`) மட்டும் நமக்குக் கிடைத்துவிட்டன. இந்த முறை, தரவுகளை ஆராய்ந்து, குறிப்பிட்ட நிபந்தனைகளின் அடிப்படையில் அவற்றை வடிகட்டுவதற்கு மிக மிக அவசியம்.

இந்த மேம்பட்ட தேர்வு முறைகள், NumPy-ஐ ஒரு சாதாரணமான எண் கணிப்பானிலிருந்து, ஒரு சக்திவாய்ந்த தரவுப் பகுப்பாய்வுக் கருவியாக மாற்றுகின்றன.



#### அத்தியாயம் ௭: NumPy − மந்திர விரிவாக்கம் (Broadcasting)

சாதாரண கணிதத்தில், `10 + 5` என்று இரண்டு எண்களைக் கூட்ட முடியும். ஆனால், ஒரு பெட்டி நிறைய ஆப்பிள்கள் (`[🍎,🍎,🍎]`) இருக்கும்போது, அதனுடன் `+ 5` என்று கூட்ட முடியுமா? முடியாது. ஒவ்வொரு ஆப்பிளுடனும் 5-ஐத் தனித்தனியாகக் கூட்ட, நாம் ஒரு `for loop`-ஐப் பயன்படுத்த வேண்டும்.

ஆனால், NumPy உலகில் ஒரு மந்திரம் இருக்கிறது. அதன் பெயர் **Broadcasting**. இந்த மந்திரத்தின் மூலம், வெவ்வேறு வடிவங்கள் மற்றும் அளவுகள் கொண்ட அணிகளை நம்மால் எளிதாகக் கூட்டவோ, கழிக்கவோ முடியும். இதற்கு NumPy எந்த `loop`-களையும் பயன்படுத்துவதில்லை.

இதை ஒரு **மந்திர பெயிண்ட் ரோலருக்கு (magical paint roller)** ஒப்பிடலாம். நீங்கள் ஒரு துளி பெயிண்ட்டை (ஒரு எண்) எடுத்து, ஒரு பெரிய சுவரில் (ஓர் அணி) தேய்க்கும்போது, அந்த ஒரு துளி பெயிண்ட்டே சுவரின் ஒவ்வொரு அங்குலத்திற்கும் பரவுவது போல, Broadcasting செயல்படுகிறது.

##### ௭.௧. Broadcasting எப்படி வேலை செய்கிறது?

Broadcasting என்பது, கணிதச் செயல்பாட்டின்போது, சிறிய அணியை, பெரிய அணியின் வடிவத்திற்குப் பொருந்தும் வகையில், **நினைவகத்தில் நகல் எடுக்காமலேயே, கிட்டத்தட்ட விரிவடையச் செய்யும்** ஒரு நுட்பமாகும். NumPy இந்த வேலையைத் தானாகவே சில விதிகளைப் பின்பற்றிச் செய்கிறது.

**எடுத்துக்காட்டு:** ஒரு வரிசை அணியையும் (`row vector`), ஒரு நிரல் அணியையும் (`column vector`) கூட்டுவோம்.

Python

```python
import numpy as np

array1 = np.array([[10, 20, 30]])  # வடிவம்: (1, 3) - ஒரு நீண்ட படுக்கை துண்டு
array2 = np.array([[1], [2], [3]])   # வடிவம்: (3, 1) - ஒரு நீண்ட செங்குத்து துண்டு

# இந்த இரண்டின் வடிவங்களும் வெவ்வேறாக உள்ளன. ஆனாலும் NumPy இவற்றைக் கூட்டும்!
result = array1 + array2

print("Array1 வடிவம்:", array1.shape)
print("Array2 வடிவம்:", array2.shape)
print("\nBroadcasting-க்குப் பின் கிடைத்த அணி:\n", result)
print("\nமுடிவின் வடிவம்:", result.shape)
```

**வெளியீடு:**

```python
Array1 வடிவம்: (1, 3)
Array2 வடிவம்: (3, 1)

Broadcasting-க்குப் பின் கிடைத்த அணி:
 [[11 21 31]
 [12 22 32]
 [13 23 33]]

முடிவின் வடிவம்: (3, 3)
```

**திரைக்குப் பின்னால் நடந்த மந்திரம் என்ன?**

1. NumPy இரண்டு அணிகளின் வடிவங்களையும் ஒப்பிட்டது: `(1, 3)` மற்றும் `(3, 1)`.
2. `array1` என்ற படுக்கை பட்டியை, `array2`-வின் உயரத்திற்குப் பொருந்தும் வகையில், **கீழ்நோக்கி கிட்டத்தட்ட விரிவாக்கியது**.
3. `array2` என்ற செங்குத்து பட்டியை, `array1`-வின் அகலத்திற்குப் பொருந்தும் வகையில், **பக்கவாட்டில் கிட்டத்தட்ட விரிவாக்கியது**.

- `array1` இப்படி மாறியது (நினைவில் அல்ல, கற்பனையில்):

  ```python
  [[10, 20, 30],
   [10, 20, 30],
   [10, 20, 30]]
  ```

- `array2` இப்படி மாறியது (நினைவில் அல்ல, கற்பனையில்):

  ```python
  [[1, 1, 1],
   [2, 2, 2],
   [3, 3, 3]]
  ```

இப்போது, இரண்டு அணிகளும் ஒரே வடிவத்தில் (`3, 3`) இருப்பதால், NumPy அவற்றை உறுப்பு வாரியாக எளிதாகக் கூட்டி, இறுதி விடையைத் தந்தது.

##### ௭.௨. Broadcasting ஏன் இவ்வளவு முக்கியம்?

Broadcasting என்பது வெறும் ஒரு வசதி மட்டுமல்ல, அது NumPy-யின் செயல்திறனுக்கு முதுகெலும்பாக இருக்கிறது.

- நினைவகச் சிக்கனம் (Memory Efficiency): 

  மேலே பார்த்த "விரிவாக்குதல்" என்பது உண்மையிலேயே நடக்காது; NumPy அப்படி நடப்பதாகக் கற்பனை செய்துகொண்டு கணக்கீடுகளைச் செய்யும். இதனால், பெரிய அணிகளை நகல் எடுக்கத் தேவையில்லாததால், மிக மிகக் குறைந்த நினைவகமே பயன்படுத்தப்படுகிறது.

- எளிமையான குறியீடு (Code Simplification): 

  for loop-கள் எழுதி நூறு வரிகளில் செய்ய வேண்டிய ஒரு வேலையை, array1 + array2 என்று ஒற்றை வரியில் அழகாக எழுதிவிட முடிகிறது. இது குறியீட்டைத் தெளிவாகவும், படிக்க எளிதாகவும் மாற்றுகிறது.

- அபார வேகம் (High Performance): 

  இந்தக் கணிதச் செயல்பாடுகள் அனைத்தும், பின்னணியில் மிக வேகமாக இயங்கும் C மொழியில் எழுதப்பட்ட vectorized operations-ஐப் பயன்படுத்துவதால், சாதாரண Python loop-களை விடப் பல நூறு மடங்கு வேகத்தில் இயங்கும்.

சுருக்கமாக, Broadcasting என்பது வெவ்வேறு வடிவ அணிகளைக் கையாளும் ஒரு திறமையான, வேகமான மற்றும் நினைவகச் சிக்கனமான வழியாகும். இதுவே NumPy-ஐ Data Scienceக்கு தேவையான கருவியாக மாற்றுகிறது.



#### அத்தியாயம் ௮: NumPy அணியில் வலம் வருதல் (Iterating Over Array)

ஒரு NumPy அணியை, ஒரு தொழிற்சாலையின் **உற்பத்திப் பட்டை (Production Line)** 🏭 என்று கற்பனை செய்துகொள்ளுங்கள். அந்தப் பட்டையில், வரிசையாகப் பொருட்கள் (`products`) நகர்ந்து வருகின்றன. ஒவ்வொரு பொருளுக்கும் சில குணாதிசயங்கள் (`attributes`) உள்ளன; உதாரணமாக, அதன் விலை, விற்கப்பட்ட எண்ணிக்கை போன்றவை.

ஒரு மேலாளராக, அந்தப் பட்டையில் உள்ள ஒவ்வொரு பொருளையும் நாம் ஆய்வு செய்ய வேண்டும். இந்த ஆய்வுப் பயணத்தை (`iteration`) நாம் பல வழிகளில் மேற்கொள்ளலாம். ஒரு சாதாரண ஆய்வாளரைப் போல மெதுவாகச் செல்வதா, அல்லது ஒரு அதிவேக ரோபோவைப் (`robot`) போலத் திறமையாகவும் வேகமாகவும் ஆய்வு செய்வதா என்பதை நாம்தான் முடிவு செய்ய வேண்டும்.

##### ௧. சாதாரண ஆய்வு முறை (Standard `for` Loop)

இதுதான் மிகவும் நேரடியான முறை. ஆய்வாளர், உற்பத்திப் பட்டையில் வரும் ஒவ்வொரு பொருளையும் (`row`) முழுமையாக எடுத்து, அதன் அனைத்து குணாதிசயங்களையும் ஆய்வு செய்வார்.

**எடுத்துக்காட்டு:** நம்மிடம் மூன்று பொருட்களின் விற்பனைத் தரவுகள் உள்ளன. ஒவ்வொரு பொருளுக்கும் `[அடையாள எண், விற்கப்பட்ட எண்ணிக்கை, ஒரு பொருளின் விலை]` என்ற விவரங்கள் உள்ளன.

Python

```python
import numpy as np

# நமது உற்பத்திப் பட்டை
sales_data = np.array([[101, 50, 2.50],  # பொருள் 101, 50 விற்றது, விலை $2.50
                       [102, 35, 15.00], # பொருள் 102, 35 விற்றது, விலை $15.00
                       [103, 80, 1.75]]) # பொருள் 103, 80 விற்றது, விலை $1.75

print("ஒவ்வொரு பொருளின் மொத்த வருவாய்:")
# ஒவ்வொரு பொருளாக ஆய்வு செய்கிறோம்
for product in sales_data:
    quantity = product[1]
    price = product[2]
    revenue = quantity * price
    print(f"பொருள் #{int(product[0])}: ${revenue:.2f}")
```

**வெளியீடு:**

```python
ஒவ்வொரு பொருளின் மொத்த வருவாய்:
பொருள் #101: $125.00
பொருள் #102: $525.00
பொருள் #103: $140.00
```

இந்த முறை சிறிய தரவுகளுக்கு ஏற்றது. ஆனால், இலட்சக்கணக்கான பொருட்கள் பட்டையில் வரும்போது, இந்த ஆய்வாளர் (Python `for` loop) மிகவும் மெதுவாகச் செயல்படுவார்.



##### ௨. அதிவேக ரோபோ ஆய்வு (`np.nditer`)

இலட்சக்கணக்கான பொருட்களை ஆய்வு செய்ய, நமக்கு ஒரு அதிவேக, புத்திசாலியான ரோபோ தேவை. அந்த ரோபோதான் **`np.nditer`**. இது பின்னணியில் C மொழியின் வேகத்தில் இயங்குவதால், நம்பமுடியாத அளவிற்குத் திறமையாகச் செயல்படும். 

**ஆய்வின்போதே பொருட்களை மாற்றுதல்**

இந்த ரோபோவால், பொருட்களை ஆய்வு செய்வது மட்டுமல்லாமல், அவற்றை மாற்றியமைக்கவும் முடியும். உதாரணமாக, ஒரு நிபந்தனையின் அடிப்படையில் பொருட்களின் எண்ணிக்கையை மாற்றுவோம்: "ஒரு பொருளின் விலை $5-க்குக் குறைவாக இருந்தால், அதன் விற்பனை எண்ணிக்கையில் 10-ஐக் கூட்டு; இல்லையென்றால் 5-ஐக் கூட்டு."

இதற்கு, **`op_flags=['readwrite']`** என்ற சிறப்பு அனுமதியை ரோபோவிற்கு வழங்க வேண்டும்.

Python

```python
# 'readwrite' அனுமதியுடன் ரோபோவை அனுப்புவோம்
for product in np.nditer(sales_data, flags=['refs_ok'], op_flags=['readwrite']):
    # product என்பது முழு வரிசையையும் குறிக்கும் ஒரு object
    price = product[...][2]  # அந்த வரிசையில் உள்ள விலையை எடுக்கிறோம்
    
    if price < 5.0:
        product[...][1] += 10 # எண்ணிக்கையை 10 கூட்டுகிறோம்
    else:
        product[...][1] += 5  # எண்ணிக்கையை 5 கூட்டுகிறோம்

print("\nநிபந்தனையின்படி மாற்றப்பட்ட விற்பனை எண்ணிக்கை:\n", sales_data)
```

**வெளியீடு:**

```python
நிபந்தனையின்படி மாற்றப்பட்ட விற்பனை எண்ணிக்கை:
 [[101.   60.    2.5]
 [102.   40.   15.  ]
 [103.   90.    1.75]]
```

இப்படிப்பட்ட சிக்கலான, நிபந்தனைகளுக்குட்பட்ட மாற்றங்களைச் செய்ய `nditer` மிகவும் சக்திவாய்ந்தது.

**ரோபோவின் ஆய்வுப் பாதையை மாற்றுதல்**

ரோபோ வழக்கமாக பொருள் வாரியாக (`row-wise`) ஆய்வு செய்யும். ஆனால், **`order='F'`** கட்டளை மூலம், அதன் ஆய்வுப் பாதையை மாற்றி, முதலில் எல்லாப் பொருட்களின் அடையாள எண்களையும், அடுத்து விற்கப்பட்ட எண்ணிக்கையையும், கடைசியாக விலைகளையும் ஆய்வு செய்யும்படி (`column-wise`) நிரல்படுத்தலாம். **`flags=['external_loop']`** என்பதைச் சேர்க்கும்போது, ரோபோ ஒவ்வொரு நிரலையும் ஒரே மூச்சில், அதிவேகமாக ஆய்வு செய்யும்.

Python

```python
# அசல் தரவை மீண்டும் பயன்படுத்துவோம்
sales_data = np.array([[101, 50, 2.50], [102, 35, 15.00], [103, 80, 1.75]])

print("\nரோபோவின் நிரல் வாரியான அதிவேக ஆய்வு:")
for column_block in np.nditer(sales_data, flags=['external_loop'], order='F'):
    print("ஒரு முழு நிரல்:", column_block)
```

**வெளியீடு:**

```python
ரோபோவின் நிரல் வாரியான அதிவேக ஆய்வு:
ஒரு முழு நிரல்: [101. 102. 103.]
ஒரு முழு நிரல்: [50. 35. 80.]
ஒரு முழு நிரல்: [ 2.5  15.    1.75]
```

தரவின் ஒரு குறிப்பிட்ட குணாதிசயத்தை மட்டும் ஆய்வு செய்ய இந்த முறை மிகவும் வேகமானது.

##### **௩**. இரண்டு உற்பத்திப் பட்டைகளை ஒப்பிடுதல் (Broadcasting Iteration)

நம்மிடம் இரண்டு வெவ்வேறு உற்பத்திப் பட்டைகள் உள்ளன. ஒன்றில் பொருட்களின் விலைகள் வருகின்றன. மற்றொன்றில், தள்ளுபடி சதவிகிதங்கள் (`discount percentages`) வருகின்றன. ஒவ்வொரு தள்ளுபடிக்கும், ஒவ்வொரு பொருளின் இறுதி விலை என்ன என்பதைக் கணக்கிட வேண்டும்.

Python

```python
product_prices = np.array([100.0, 200.0, 50.0])
discount_multipliers = np.array([[0.9], [0.8]]) # 10% மற்றும் 20% தள்ளுபடி

print("\nஒவ்வொரு தள்ளுபடிக்கும் இறுதி விலைகள்:")
# இரண்டு பட்டைகளையும் ஒரே நேரத்தில் ஆய்வு செய்ய ரோபோவை அனுப்புவோம்
for price, discount in np.nditer([product_prices, discount_multipliers]):
    final_price = price * discount
    print(f"₹{price:.2f} கொண்ட பொருள் {int((1-discount)*100)}% தள்ளுபடியில்: ₹{final_price:.2f}")
```

**வெளியீடு:**

```python
ஒவ்வொரு தள்ளுபடிக்கும் இறுதி விலைகள்:
₹100.00 கொண்ட பொருள் 10% தள்ளுபடியில்: ₹90.00
₹200.00 கொண்ட பொருள் 10% தள்ளுபடியில்: ₹180.00
₹50.00 கொண்ட பொருள் 10% தள்ளுபடியில்: ₹45.00
₹100.00 கொண்ட பொருள் 20% தள்ளுபடியில்: ₹80.00
₹200.00 கொண்ட பொருள் 20% தள்ளுபடியில்: ₹160.00
₹50.00 கொண்ட பொருள் 20% தள்ளுபடியில்: ₹40.00
```

Broadcasting விதிகளைப் பயன்படுத்தி, `nditer` ரோபோ இரண்டு வெவ்வேறு வடிவங்கள் கொண்ட தரவுப் பட்டைகளையும் எப்படி ஒருங்கிணைத்து ஆய்வு செய்ய வேண்டும் என்பதைத் தானாகவே புரிந்துகொண்டு செயல்படுகிறது.

| முறை (Method)    | உவமை (Analogy) | எப்போது பயன்படுத்த வேண்டும்?                               |
| ---------------- | -------------- | ----------------------------------------------------- |
| Basic `for` loop | சாதாரண ஆய்வாளர்  | எளிய, பொருள் வாரியான ஆய்வுகளுக்கு (சிறிய தரவு).          |
| `np.nditer`      | அதிவேக ரோபோ    | வேகம், சிக்கலான நிபந்தனைகள், மற்றும் மாற்றங்கள் தேவைப்படும்போது. |



#### அத்தியாயம் **௯**: NumPy அணியைக் கையாளுதல் (Array Manipulation)

ஒரு NumPy அணியை, ஒரு சிற்பியின் கையில் இருக்கும் **களிமண் தொகுதி (block of clay)** என்று கற்பனை செய்துகொள்ளுங்கள். ஒரு திறமையான சிற்பி, அந்தக் களிமண்ணை வெட்டி, நீட்டி, சுழற்றி, இணைத்து, பிரித்து ஒரு அழகான சிற்பத்தை உருவாக்குவார். அதுபோல, NumPy நமக்குத் தரும் கருவிகளைக் கொண்டு, நம்முடைய தரவு என்ற களிமண்ணை நமக்குத் தேவையான வடிவத்திற்கு மாற்றியமைக்க முடியும்.

இந்த அத்தியாயத்தில், ஒரு சிற்பியைப் போல, நம் தரவுத் தொகுதியை வெவ்வேறு கருவிகளைக் கொண்டு எப்படிச் செதுக்குவது என்று படிப்படியாகக் கற்றுக்கொள்வோம்.

##### பகுதி **௧**: வடிவத்தைச் செதுக்குதல் (Reshaping and Transposing)

முதலில், நம் களிமண் தொகுதியின் அடிப்படை வடிவத்தை மாற்றுவதற்கான கருவிகளைப் பார்ப்போம்.

`numpy.reshape` – களிமண்ணுக்குப் புதிய வடிவம் கொடுத்தல்

இது ஒரு சிற்பியின் மிக அடிப்படையான கருவி. ஒரு நீண்ட, தட்டையான களிமண் பட்டையை, ஒரு கனசதுர வடிவத்திற்கு மாற்றுவது போல, `reshape` ஒரு பரிமாண அணியை (`1D array`) பல பரிமாண அணியாக (`multi-dimensional array`) மாற்ற உதவுகிறது.

**முக்கிய விதி:** களிமண்ணின் மொத்த அளவு மாறக்கூடாது. அதாவது, அணியில் உள்ள மொத்த உறுப்புகளின் எண்ணிக்கை, புதிய வடிவத்திற்கும் பொருந்த வேண்டும்.

Python

```python
import numpy as np

# 12 உறுப்புகள் கொண்ட ஒரு நீண்ட களிமண் பட்டை
clay_strip = np.arange(12)  # [0, 1, 2, ..., 11]
print("பழைய வடிவம்:", clay_strip.shape)

# அதை 3 வரிசைகள், 4 நிரல்கள் கொண்ட செவ்வகமாக மாற்றுவோம்
clay_block = clay_strip.reshape(3, 4)
print("\nபுதிய வடிவம் (3, 4):\n", clay_block)
```

**வெளியீடு:**

```python
பழைய வடிவம்: (12,)

புதிய வடிவம் (3, 4):
 [[ 0  1  2  3]
 [ 4  5  6  7]
 [ 8  9 10 11]]
```

`numpy.transpose` மற்றும் `.T` – சிற்பத்தைத் திருப்புதல்

இப்போது, நாம் உருவாக்கிய களிமண் சிற்பத்தின் வரிசைகளை நிரல்களாகவும், நிரல்களை வரிசைகளாகவும், அதாவது கிடைமட்டத்தை செங்குத்தாகவும், செங்குத்தைக் கிடைமட்டமாகவும் திருப்ப வேண்டும். இதற்கு `transpose` உதவுகிறது. இதன் சுருக்கமான வழிதான் `.T`.

Python

```python
# (3, 4) வடிவ சிற்பத்தை திருப்புவோம்
transposed_block = clay_block.transpose()
# அல்லது சுருக்கமாக: transposed_block = clay_block.T

print("\nதிருப்பப்பட்ட வடிவம் (4, 3):\n", transposed_block)
```

**வெளியீடு:**

```python
திருப்பப்பட்ட வடிவம் (4, 3):
 [[ 0  4  8]
 [ 1  5  9]
 [ 2  6 10]
 [ 3  7 11]]
```

##### பகுதி **௨**: தட்டையாக்குதல் மற்றும் விரித்தல் (Flattening and Expanding)

சில நேரங்களில், நம்முடைய பல அடுக்கு சிற்பத்தை ஒரே நேர்கோடாகத் தட்டையாக்க வேண்டியிருக்கும், அல்லது ஒரு நேர்கோட்டிற்குப் புதிய பரிமாணத்தைச் சேர்க்க வேண்டியிருக்கும்.

`flatten` மற்றும் `ravel` – சிற்பத்தை ஒரே நேர்கோடாக்குதல்

இந்த இரண்டு கருவிகளுமே, பல பரிமாண அணியை ஒற்றைப் பரிமாண அணியாக (`1D array`) மாற்றும். ஆனால், அவற்றுக்கு இடையே ஒரு முக்கியமான வேறுபாடு உள்ளது.

- **`flatten`:** இது சிற்பத்தின் ஒரு **புதிய நகலை (new copy)** உருவாக்கி அதைத் தட்டையாக்கும். அசல் சிற்பத்தில் மாற்றம் செய்தால், இந்த நகல் மாறாது.
- **`ravel`:** இது பெரும்பாலும் சிற்பத்தின் ஒரு **பார்வையை (view)** மட்டுமே தரும். அசல் சிற்பத்தில் மாற்றம் செய்தால், இந்தத் தட்டையான வடிவமும் மாறும். இது நினைவகத்தைச் சிக்கனப்படுத்தும்.

Python

```python
# (3, 4) வடிவ சிற்பத்தைத் தட்டையாக்குவோம்
flattened_copy = clay_block.flatten()
raveled_view = clay_block.ravel()

print("Flatten மூலம்:", flattened_copy)
print("Ravel மூலம்:", raveled_view)

# இப்போது அசல் சிற்பத்தில் ஒரு மாற்றத்தைச் செய்வோம்
clay_block[0, 0] = 99

print("\nமாற்றத்திற்குப் பின் Ravel:", raveled_view) 
print("மாற்றத்திற்குப் பின் Flatten:", flattened_copy) 
```

**வெளியீடு:**

```
...
மாற்றத்திற்குப் பின் Ravel: [99  1  2  3  4  5  6  7  8  9 10 11]
மாற்றத்திற்குப் பின் Flatten: [ 0  1  2  3  4  5  6  7  8  9 10 11]
```

**முக்கியக் குறிப்பு:** நினைவகச் சிக்கனம் தேவைப்படும்போது `ravel`-ஐப் பயன்படுத்துவது சிறந்தது.

`expand_dims` மற்றும் `squeeze` – புதிய பரிமாணத்தைச் சேர்த்தல் மற்றும் நீக்குதல்

- **`expand_dims`:** ஒரு தட்டையான களிமண் பட்டைக்கு, உயரத்தைக் கொடுத்து அதை ஒரு 3D பொருளாக மாற்றுவது போல, இது ஒரு அணிக்கு புதிய பரிமாணத்தை (`axis`) சேர்க்கிறது.
- **`squeeze`:** தேவையற்ற, ஒற்றை உறுப்பு மட்டுமே கொண்ட பரிமாணங்களை (உதாரணமாக, ஒரு பெட்டிக்குள் இன்னொரு பெட்டி, அதற்குள் ஒரே ஒரு பொருள் இருப்பது போல) நீக்கி, அணியைச் சுருக்குகிறது.

Python

```python
strip = np.array([1, 2, 3]) # வடிவம்: (3,)

# ஒரு புதிய பரிமாணத்தைச் சேர்ப்போம்
expanded = np.expand_dims(strip, axis=0)
print("விரிவாக்கப்பட்ட அணி:", expanded)
print("புதிய வடிவம்:", expanded.shape) # வடிவம்: (1, 3)

# தேவையற்ற பரிமாணத்தை நீக்குவோம்
squeezed = np.squeeze(expanded)
print("\nசுருக்கப்பட்ட அணி:", squeezed)
print("மீண்டும் பழைய வடிவம்:", squeezed.shape) # வடிவம்: (3,)
```

##### பகுதி **௩**: இணைத்தல் மற்றும் பிரித்தல் (Joining and Splitting)

ஒரு சிற்பி, பல களிமண் துண்டுகளை இணைத்து ஒரு பெரிய சிற்பத்தையோ, அல்லது ஒரு பெரிய துண்டைப் பிரித்து பல சிறிய சிற்பங்களையோ உருவாக்குவார்.

`concatenate`, `vstack`, `hstack` – களிமண் துண்டுகளை இணைத்தல்

- **`concatenate`:** இரண்டு அல்லது அதற்கு மேற்பட்ட அணிகளை, குறிப்பிட்ட அச்சு (`axis`) வழியாக ஒன்றன் பின் ஒன்றாக இணைக்கிறது.
- **`vstack`:** (Vertical Stack) அணிகளை ஒன்றன் கீழ் ஒன்றாக, செங்குத்தாக அடுக்கி இணைக்கிறது.
- **`hstack`:** (Horizontal Stack) அணிகளை ஒன்றன் பின் ஒன்றாக, கிடைமட்டமாக இணைக்கிறது.

Python

```python
clay1 = np.array([[1, 2], [3, 4]])
clay2 = np.array([[5, 6], [7, 8]])

# செங்குத்தாக இணைத்தல்
v_stacked = np.vstack((clay1, clay2))
print("செங்குத்து இணைப்பு (vstack):\n", v_stacked)

# கிடைமட்டமாக இணைத்தல்
h_stacked = np.hstack((clay1, clay2))
print("\nகிடைமட்ட இணைப்பு (hstack):\n", h_stacked)
```

`split`, `vsplit`, `hsplit` – களிமண் தொகுதியைப் பிரித்தல்

இது இணைத்தலுக்கு நேர்மாறான செயல். `split`, ஒரு அணியை பல சமமான சிறிய அணிகளாகப் பிரிக்கிறது. `vsplit` செங்குத்தாகவும், `hsplit` கிடைமட்டமாகவும் பிரிக்கிறது.

Python

```python
large_block = np.arange(16).reshape(4, 4)

# இரண்டாகச் செங்குத்தாகப் பிரித்தல்
v_splitted = np.vsplit(large_block, 2)
print("செங்குத்துப் பிரிவுகள்:\n", v_splitted)
```

##### பகுதி **௪**: உறுப்புகளைச் சேர்த்தல், நீக்குதல் மற்றும் சீராக்குதல்

இறுதியாக, சிற்பத்தைச் செதுக்கி, தேவையற்ற பகுதிகளை நீக்கி, புதிய பகுதிகளைச் சேர்த்து, அதை மெருகேற்றுவோம்.

`append`, `insert`, `delete` – சேர்த்தல் மற்றும் நீக்குதல்

- **`append`:** அணியின் இறுதியில் புதிய உறுப்புகளைச் சேர்க்கிறது.
- **`insert`:** அணியின் குறிப்பிட்ட இடத்தில் (`index`) புதிய உறுப்புகளைச் செருகுகிறது.
- **`delete`:** அணியின் குறிப்பிட்ட இடத்தில் உள்ள உறுப்புகளை நீக்குகிறது.

**முக்கியக் குறிப்பு:** இந்த செயல்பாடுகள், அசல் அணியை மாற்றாது; ஒரு **புதிய அணியை** உருவாக்கும்.

Python

```python
arr = np.array([1, 2, 5, 6])

# இறுதியில் 7, 8-ஐச் சேர்த்தல்
appended = np.append(arr, [7, 8])
print("Append:", appended)

# 2-வது இடத்தில் (index 2) 3, 4-ஐச் செருகுதல்
inserted = np.insert(arr, 2, [3, 4])
print("Insert:", inserted)

# 1-வது இடத்தில் (index 1) உள்ள உறுப்பை நீக்குதல்
deleted = np.delete(arr, 1)
print("Delete:", deleted)
```

`unique` – நகல்களை நீக்கி மெருகேற்றுதல்

ஒரு சிற்பத்தில் ஒரே மாதிரியான பகுதிகள் மீண்டும் மீண்டும் வந்தால், அதைச் சீராக்குவது போல, `unique` ஓர் அணியில் மீண்டும் மீண்டும் வரும் உறுப்புகளை (`duplicates`) நீக்கி, தனித்துவமான உறுப்புகளை மட்டுமே தருகிறது.

Python

```python
messy_clay = np.array([1, 2, 2, 3, 4, 1, 4, 5])
unique_elements = np.unique(messy_clay)
print("\nதனித்துவமான உறுப்புகள்:", unique_elements)
```

**வெளியீடு:**

```python
தனித்துவமான உறுப்புகள்: [1 2 3 4 5]
```

இந்தக் கருவிகளைக் கொண்டு, உங்கள் தரவு என்ற களிமண்ணை, உங்கள் கற்பனைக்கு ஏற்றவாறு எந்த வடிவத்திலும் செதுக்க முடியும்.

#### அத்தியாயம் **௰**: NumPy – இருமச் செயல்பாடுகள் (Binary Operators)

நாம் கணினிக்குக் கொடுக்கும் ஒவ்வொரு எண்ணும், தகவலும், அதன் இதயத்தில் `0` மற்றும் `1` என்ற இரும எண்களாகவே சேமிக்கப்படுகிறது. இதை, ஒரு **கட்டுப்பாட்டுப் பலகையில் (Control Panel)** உள்ள சுவிட்சுகள் (`switches`) என்று கற்பனை செய்துகொள்ளுங்கள். `1` என்றால் சுவிட்ச் **ON** நிலையில் உள்ளது, `0` என்றால் **OFF** நிலையில் உள்ளது.

NumPy-யின் இருமச் செயல்பாடுகள், இந்தக் கட்டுப்பாட்டுப் பலகையில் உள்ள ஒவ்வொரு சுவிட்சையும் தனித்தனியாகக் கையாளும் கருவிகளை நமக்குத் தருகின்றன. இதன் மூலம், மிகத் திறமையாகவும் வேகமாகவும் தரவைக் கையாள முடியும்.

**நமது எடுத்துக்காட்டு:** ஒரு கோப்பிற்கான அனுமதிகளை (`permissions`) 4 சுவிட்சுகள் கொண்ட ஒரு கட்டுப்பாட்டுப் பலகையில் சேமிப்போம்.

- `8 (`23`)`: படிக்கும் அனுமதி (READ)
- `4 (`22`)`: எழுதும் அனுமதி (WRITE)
- `2 (`21`)`: இயக்கும் அனுமதி (EXECUTE)
- `1 (`20`)`: பகிரும் அனுமதி (SHARE)

ஒரு பயனரின் அனுமதி `13` என்றால், அதன் இரும வடிவம் `1101`. அதாவது, அவருக்கு READ (`8`), WRITE (`4`), SHARE (`1`) அனுமதிகள் உள்ளன, ஆனால் EXECUTE (`2`) அனுமதி இல்லை (`8 + 4 + 0 + 1 = 13`).

##### க. தர்க்கரீதியான சுவிட்சுகள் (Logical Switches)

`numpy.bitwise_and` – ஒரு குறிப்பிட்ட சுவிட்ச் ON-ல் உள்ளதா எனச் சோதிக்க

ஒரு பயனருக்கு `WRITE` அனுமதி உள்ளதா என எப்படிச் சோதிப்பது?

`WRITE` சுவிட்சை மட்டும் ON செய்து, ஒரு "மாஸ்க்" (`mask`) உருவாக்குவோம் (`WRITE_MASK = 4`, அதாவது `0100`). இப்போது, பயனரின் அனுமதியையும் இந்த மாஸ்கையும் `AND` செய்தால், அந்தச் சுவிட்ச் ON-ல் இருந்தால் மட்டுமே நமக்கு ஒரு மதிப்பு கிடைக்கும்.

**விதி:** `AND` செயல்பாட்டில், இரண்டு சுவிட்சுகளும் `1` (ON) ஆக இருந்தால் மட்டுமே, வெளியீடு `1` (ON) ஆக இருக்கும்.

Python

```python
import numpy as np

user_permission = 13  # இருமம்: 1101
WRITE_MASK = 4      # இருமம்: 0100

# AND செயல்பாட்டைச் செய்வோம்
has_write_permission = np.bitwise_and(user_permission, WRITE_MASK)

print(f"பயனர் அனுமதி (1101) AND மாஸ்க் (0100) = {has_write_permission} (இருமம்: {has_write_permission:04b})")

if has_write_permission:
    print("பயனருக்கு WRITE அனுமதி உள்ளது.")
```

**வெளியீடு:**

```python
பயனர் அனுமதி (1101) AND மாஸ்க் (0100) = 4 (இருமம்: 0100)
பயனருக்கு WRITE அனுமதி உள்ளது.
```

`numpy.bitwise_or` – ஒரு குறிப்பிட்ட சுவிட்சை ON செய்தல்

ஒரு பயனருக்கு, மற்ற அனுமதிகளை மாற்றாமல், `EXECUTE` அனுமதியை மட்டும் புதிதாக வழங்குவது எப்படி?

`EXECUTE` சுவிட்சை மட்டும் ON செய்து, ஒரு மாஸ்க் உருவாக்குவோம் (`EXECUTE_MASK = 2`, அதாவது `0010`). இதை, பயனரின் அனுமதியுடன் `OR` செய்தால், அந்தச் சுவிட்ச் மட்டும் ON நிலைக்கு மாறிவிடும்.

**விதி:** `OR` செயல்பாட்டில், ஏதாவது ஒரு சுவிட்ச் `1` (ON) ஆக இருந்தாலும், வெளியீடு `1` (ON) ஆக இருக்கும்.

Python

```python
user_permission = 13  # இருமம்: 1101
EXECUTE_MASK = 2    # இருமம்: 0010

# OR செயல்பாட்டைச் செய்வோம்
new_permission = np.bitwise_or(user_permission, EXECUTE_MASK)

print(f"புதிய அனுமதி: {new_permission} (இருமம்: {new_permission:04b})")
```

**வெளியீடு:**

```python
புதிய அனுமதி: 15 (இருமம்: 1111)
```

`EXECUTE` சுவிட்ச் இப்போது ON ஆகிவிட்டது (`1101` -> `1111`).

`numpy.invert` – எல்லா சுவிட்சுகளையும் திருப்புதல்

`invert` (அல்லது `bitwise_not`) என்ற கருவி, கட்டுப்பாட்டுப் பலகையில் உள்ள **எல்லா சுவிட்சுகளையும்** ஒரே நேரத்தில் தலைகீழாக மாற்றும். ON-ல் இருப்பவை OFF ஆகும், OFF-ல் இருப்பவை ON ஆகும்.

**குறிப்பு:** இது, கணினி பயன்படுத்தும் மொத்த பிட்களின் (bits) அடிப்படையில் செயல்படும். நாம் `uint8` (8-bit integer) பயன்படுத்தினால், 8 சுவிட்சுகளும் தலைகீழாக மாறும்.

Python

```python
# 8-bit கட்டுப்பாட்டுப் பலகையில் நமது அனுமதி
permission_8bit = np.array([13], dtype=np.uint8) # இருமம்: 00001101

inverted_permission = np.invert(permission_8bit)

print(f" தலைகீழ் அனுமதி: {inverted_permission[0]} (இருமம்: {inverted_permission[0]:08b})")
```

**வெளியீடு:**

```python
 தலைகீழ் அனுமதி: 242 (இருமம்: 11110010)
```

##### **௨** . இடமாறும் சுவிட்சுகள் (Shifting Switches)

இந்தக் கருவிகள், கட்டுப்பாட்டுப் பலகையில் உள்ள சுவிட்சுகளை இடதுபுறமாகவோ வலதுபுறமாகவோ நகர்த்தும். இது, எண்களை 2-இன் அடுக்குகளால் பெருக்குவதற்கும் வகுப்பதற்கும் ஒரு அதிவேக வழியாகும். 

`numpy.left_shift` – மதிப்பை இரட்டிப்பு செய்தல்

சுவிட்சுகளை ஒரு இடம் இடதுபுறம் நகர்த்துவது, எண்ணை `2`-ஆல் பெருக்குவதற்குச் சமம். இரண்டு இடங்கள் நகர்த்துவது, `4`-ஆல் ($2^2$) பெருக்குவதற்குச் சமம்.

Python

```
value = 5  # இருமம்: 0101
# 2 இடங்கள் இடதுபுறம் நகர்த்துவோம் (5 * 4 = 20)
shifted_left = np.left_shift(value, 2)

print(f"{value} (0101) இடதுபுறம் நகர்த்தினால்: {shifted_left} (இருமம்: 10100)")
```

**வெளியீடு:**

```
5 (0101) இடதுபுறம் நகர்த்தினால்: 20 (இருமம்: 10100)
```

`numpy.right_shift` – மதிப்பை பாதியாகக் குறைத்தல்

சுவிட்சுகளை ஒரு இடம் வலதுபுறம் நகர்த்துவது, எண்ணை `2`-ஆல் வகுப்பதற்குச் சமம்.

Python

```
value = 40  # இருமம்: 101000
# 3 இடங்கள் வலதுபுறம் நகர்த்துவோம் (40 / 8 = 5)
shifted_right = np.right_shift(value, 3)

print(f"{value} (101000) வலதுபுறம் நகர்த்தினால்: {shifted_right} (இருமம்: 000101)")
```

**வெளியீடு:**

```
40 (101000) வலதுபுறம் நகர்த்தினால்: 5 (இருமம்: 000101)
```

இந்த இருமச் செயல்பாடுகள், மிகக் குறைந்த அளவில் தரவைக் கையாள்வதால், இவை தரவு சுருக்கம்(compression),  image processing மற்றும் உயர் செயல்திறன் தேவைப்படும் பல இடங்களில் அடித்தளமாக விளங்குகின்றன.



#  Will update soon with other chapters

