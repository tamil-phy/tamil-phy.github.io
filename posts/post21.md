## கம்ப்யூடேஷனல் கிராப்ஸ் - முழுமையான விளக்கம் 

நாம் கணினிகளுக்கு எப்படி கணித கணக்குகளை செய்யச் சொல்கிறோம் என்பதை ஒரு புதிய கோணத்தில் பார்க்கப் போகிறோம். இதை "கம்ப்யூடேஷனல் கிராப்ஸ்" என்று அழைக்கிறோம். இது ஒரு பெரிய மரம் போன்ற வரைபடம், ஒவ்வொரு கணக்கும் ஒரு சிறிய கிளை போல.

**எளிய உதாரணத்தில் தொடங்குவோம்:**

நம்மிடம் இரண்டு எண்கள் உள்ளன என்று வைத்துக்கொள்வோம்:
- x = 3 (இது நமது இன்புட்)
- w = 2 (இது ஒரு வெயிட், அதாவது ஒரு முக்கியமான எண்)

இப்போது ஒரு எளிய கணக்கு:
y = x * w
y = 3 * 2
y = 6

இதை கிராப் ஆக எப்படி வரைவது?

```
[3] (x)
 |
 * (பெருக்கல்)
 |
[2] (w)
 |
[6] (y)
```

இது ஒரு மிக எளிய கம்ப்யூடேஷனல் கிராப். இதில்:
- சுற்று வட்டங்கள் டேட்டா (எண்கள்)
- சதுரங்கள் ஆபரேஷன்ஸ் (கணித செயல்பாடுகள்)

**இன்னும் சற்று சிக்கலான உதாரணம்:**

இப்போது ஒரு பயஸ் (b) சேர்ப்போம்:
z = (x * w) + b
x=3, w=2, b=1 எனில்:
z = (3*2)+1 = 7

கிராப்:

```
[3] (x)
 |
 * (பெருக்கல்) → [6] (இண்டர்மீடியட் வால்யூ)
 |                  |
[2] (w)            + (கூட்டல்)
                     |
                    [1] (b)
                     |
                    [7] (z)
```

**PyTorch-இல் இதை எப்படி செய்வது?**

```python
import torch

x = torch.tensor(3.0, requires_grad=True)
w = torch.tensor(2.0, requires_grad=True)
b = torch.tensor(1.0, requires_grad=True)

z = x * w + b
```

இங்கே `requires_grad=True` என்றால் "இந்த எண்களின் மதிப்பு மாறினால் விளைவு எப்படி மாறும் என்பதை கண்காணி" என்று அர்த்தம்.

**ஏன் இது முக்கியம்?**

நாம் டீப் லர்னிங் மாடல்களை டிரெயின் செய்யும்போது, "ஒவ்வொரு வெயிட் மற்றும் பயஸ் எவ்வளவு மாற்றம் வேண்டும்" என்பதை கணக்கிட வேண்டும். இதைத்தான் பேக்ப்ரொபகேஷன் என்று சொல்கிறோம்.

**ஒரு முழுமையான உதாரணம்:**

1. ஃபார்வார்ட் பாஸ் (முன்னோக்கி கணக்கீடு):
```python
x = torch.tensor([1., 2., 3.], requires_grad=True)
w = torch.tensor([0.5, 0.3, 0.2], requires_grad=True)
b = torch.tensor(1.0, requires_grad=True)

# கணக்கீடுகள்
linear = x * w + b       # [1*0.5+1, 2*0.3+1, 3*0.2+1] = [1.5, 1.6, 1.6]
activation = torch.sigmoid(linear)  # சிக்மாய்டு செயல்பாடு
loss = torch.mean(activation)     # சராசரி loss
```

2. பேக்வர்ட் பாஸ் (பின்னோக்கி கிரேடியன்ட் கணக்கீடு):
```python
loss.backward()  # மந்திரம் இங்கே நடக்கிறது!

print("dL/dx:", x.grad)  # x-க்கான கிரேடியன்ட்
print("dL/dw:", w.grad)  # w-க்கான கிரேடியன்ட்
print("dL/db:", b.grad)  # b-க்கான கிரேடியன்ட்
```

**இதன் விளைவு என்ன?**

PyTorch தானாகவே:
1. எல்லா கணக்குகளையும் டிரேக் செய்கிறது
2. loss-ல் இருந்து தொடங்கி பின்னோக்கி செல்கிறது
3. ஒவ்வொரு வெயிட் மற்றும் பயஸ் எவ்வளவு மாற்றம் வேண்டும் என்பதை கணக்கிடுகிறது

**நிஜ உலக ஒப்புமை:**

இதை ஒரு தொழிற்சாலை அசெம்பிளி லைன் போல நினைத்துப் பாருங்கள்:
- ஒவ்வொரு ஊழியரும் (ஆபரேஷன்) ஒரு சிறிய பணியை செய்கிறார்
- இறுதி தயாரிப்பு (loss) தரமாக இல்லாவிட்டால், யார் எந்த பகுதியில் தவறு செய்தார் என்பதை பின்னோக்கி பார்க்கிறோம்
- அடுத்த முறை சிறப்பாக செய்ய அவருக்கு வழிகாட்டுகிறோம் (கிரேடியன்ட்)

**முக்கிய குறிப்புகள்:**

1. `requires_grad=True` இல்லையென்றால் கிரேடியன்ட் கணக்கிடப்படாது
2. `loss.backward()` ஒவ்வொரு முறையும் கிராபை அழிக்கும்
3. மீண்டும் கணக்கிட வேண்டுமென்றால் `retain_graph=True` பயன்படுத்தவும்
4. `with torch.no_grad():` பயன்படுத்தி கிராப் டிரேக்கிங் நிறுத்தலாம்

**ஏன் PyTorch-இன் கிராப்கள் சிறப்பு?**

1. டைனமிக்: ரன் டைமில் மாற்றலாம்
   ```python
   if x > 0:
       y = x * w
   else:
       y = x + w
   ```
2. இன்டூட்டிவ்: Python கோட் போலவே இருக்கும்
3. டிபக்கிங் எளிது: ஒவ்வொரு ஸ்டெப்பையும் பார்க்கலாம்

**மேம்பட்ட செயல்பாடுகள்:**

1. கஸ்டம் ஆபரேஷன்ஸ்:
   ```python
   class MyFunction(torch.autograd.Function):
       @staticmethod
       def forward(ctx, input):
           # ஃபார்வார்ட் கணக்கீடு
           return result
       
       @staticmethod
       def backward(ctx, grad_output):
           # கிரேடியன்ட் கணக்கீடு
           return grad_input
   ```

2. கிராப் விஷுவலைசேஷன்:
   ```python
   from torchviz import make_dot
   make_dot(z, params={'x':x, 'w':w, 'b':b})
   ```

**பொதுவான தவறுகள்:**

1. `backward()`-க்கு முன் `grad` வரிசைப்படுத்த மறத்தல்
   ```python
   optimizer.zero_grad()  # முக்கியம்!
   loss.backward()
   optimizer.step()
   ```

2. `detach()` மறதி:
   ```python
   # தவறு:
   y = x * 2
   z = y + 1
   z.backward()  # y-யும் கிராபில் இருக்கும்
   
   # சரி:
   y = x * 2
   z = y.detach() + 1  # y-ஐ கிராபில் இருந்து துண்டிக்கிறது
   ```

